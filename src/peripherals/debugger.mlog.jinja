#% set LOOKUP_PROC_SIZE = 260
#% set ROM_BYTE_OFFSET = 174
#% set ROM_PROC_BYTES = 16384
#% set RAM_PROC_VARS = 4096
#% set ROM_START = '0x00000000'
#% set RAM_START = '0x80000000'
#% set MMIO_START = '0xf0000000'
#% set PAGESIZE = 2**12

#% set CPU = 'processor17'
#% set CSRS = 'processor18'
#% set REGISTERS = 'cell1'
#% set DISPLAY = 'display1'
#% set SWITCH = 'switch1'
#% set UART0 = 'bank1'
#% set UART1 = 'bank2'
#% set UART2 = 'bank3'
#% set UART3 = 'bank4'

#% macro print(col, row)
   #{{'\n'}}    draw print {{ 11 + col * 7 }} {{ 512 - 6 - row * 13 }} topLeft
    drawflush {{DISPLAY}}
#% endmacro

#% macro rect(col, row, width, height)
   #{{'\n'}}    draw rect {{ 11 + col * 7 }} {{ 512 - 6 - row * 13 - 3 }} {{ width * 7 }} {{ height * -13 }}
#% endmacro

reset:
    setrate 5000
    set MARKER_START_ID 0
    set DBG_VIRT_ADDR {{# '0x' }}

    op add i MARKER_START_ID 8
reset_markers:
    op sub i i 1
    setmarker remove i
    jump reset_markers greaterThan i MARKER_START_ID

reset_loop:
    wait 1e-5
    sensor enabled {{SWITCH}} @enabled
    jump reset_loop equal enabled false

    set i -1
reset__find_lookup_start:
    op add i i 1
    getlink block i
    sensor type block @type
    jump reset__find_lookup_start notEqual type @micro-processor
    read type_var block "_type"
    jump reset__find_lookup_start notEqual type_var "lookup"

    control enabled {{SWITCH}} true

    draw reset
    draw color 255 255 255 255
    draw clear 0 0 0
    drawflush {{DISPLAY}}

# {% macro print_str() %}print "{{- caller() -}}"{% endmacro %}

#% call print_str()
    #{- 'pc    =\\n'
    #{- 'op    =\\n'
    #{- 'imm   =\\n'
    #{- 'rs1id =\\n'
    #{- 'rs1   =\\n'
    #{- 'rs2id =\\n'
    #{- 'rs2   =\\n'
    #{- 'rdid  =\\n\\n'

    #{- 'satp  =\\n'
    #{- 'addr1 =\\n'
    #{- 'pte1  =\\n'
    #{- 'addr0 =\\n'
    #{- 'pte0  =\\n'
    #{- 'addr  =\\n'
    #{- 'val   =\\n'
#%- endcall

    #{ print(0, 0)

#% call print_str()
    #{- 'x0  (zero)  =\\n'
    #{- 'x1  (ra)    =\\n'
    #{- 'x2  (sp)    =\\n'
    #{- 'x3  (gp)    =\\n'
    #{- 'x4  (tp)    =\\n'
    #{- 'x5  (t0)    =\\n'
    #{- 'x6  (t1)    =\\n'
    #{- 'x7  (t2)    =\\n'
    #{- 'x8  (s0/fp) =\\n'
    #{- 'x9  (s1)    =\\n'
    #{- 'x10 (a0)    =\\n'
    #{- 'x11 (a1)    =\\n'
    #{- 'x12 (a2)    =\\n'
    #{- 'x13 (a3)    =\\n'
    #{- 'x14 (a4)    =\\n'
    #{- 'x15 (a5)    =\\n'
#%- endcall

    #{ print(21, 0)

#% call print_str()
    #{- 'x16 (a6)  =\\n'
    #{- 'x17 (a7)  =\\n'
    #{- 'x18 (s2)  =\\n'
    #{- 'x19 (s3)  =\\n'
    #{- 'x20 (s4)  =\\n'
    #{- 'x21 (s5)  =\\n'
    #{- 'x22 (s6)  =\\n'
    #{- 'x23 (s7)  =\\n'
    #{- 'x24 (s8)  =\\n'
    #{- 'x25 (s9)  =\\n'
    #{- 'x26 (s10) =\\n'
    #{- 'x27 (s11) =\\n'
    #{- 'x28 (t3)  =\\n'
    #{- 'x29 (t4)  =\\n'
    #{- 'x30 (t5)  =\\n'
    #{- 'x31 (t6)  =\\n'
#%- endcall

    #{ print(48, 0)

loop:
    sensor enabled {{SWITCH}} @enabled
    jump reset equal enabled false

    set mark_memory_id MARKER_START_ID

    read MEMORY_X {{CPU}} "MEMORY_X"
    read MEMORY_Y {{CPU}} "MEMORY_Y"
    read MEMORY_WIDTH {{CPU}} "MEMORY_WIDTH"

    read PROGRAM_ROM_SIZE {{CPU}} "PROGRAM_ROM_SIZE"
    read DATA_ROM_SIZE {{CPU}} "DATA_ROM_SIZE"
    read ROM_SIZE {{CPU}} "ROM_SIZE"
    read ICACHE_SIZE {{CPU}} "ICACHE_SIZE"

    read RAM_START_PROC {{CPU}} "RAM_START_PROC"
    read RAM_END {{CPU}} "RAM_END"

    set ICACHE_START RAM_END
    op add ICACHE_END ICACHE_START ICACHE_SIZE
    
    read mcycle {{CSRS}} "{{ 'mcycle'|csr }}"
    read mcycleh {{CSRS}} "{{ 'mcycleh'|csr }}"
    op shl mcycleh mcycleh 32
    op add mcycle mcycle mcycleh
    
    read mtime {{CPU}} "csr_mtime"
    read mtimeh {{CPU}} "csr_mtimeh"
    op shl mtimeh mtimeh 32
    op add mtime mtime mtimeh
    
    read mtimecmp {{CPU}} "csr_mtimecmp"
    read mtimecmph {{CPU}} "csr_mtimecmph"
    op shl mtimecmph mtimecmph 32
    op add mtimecmp mtimecmp mtimecmph
    
    read minstret {{CPU}} "csr_minstret"
    read minstreth {{CPU}} "csr_minstreth"
    op shl minstreth minstreth 32
    op add minstret minstret minstreth

    read satp {{CPU}} "csr_satp"
    read sscratch {{CSRS}} "{{ 'sscratch'|csr }}"
    read stvec {{CSRS}} "{{ 'stvec'|csr }}"
    read sepc {{CSRS}} "{{ 'sepc'|csr }}"
    read scause {{CSRS}} "{{ 'scause'|csr }}"
    read stval {{CSRS}} "{{ 'stval'|csr }}"

    read mstatus {{CPU}} "csr_mstatus"
    read mip {{CPU}} "csr_mip"
    read mie {{CPU}} "csr_mie"

    read state {{CPU}} "state"
    read pc {{CPU}} "pc"
    read op_id {{CPU}} "op_id"
    read rs1_id {{CPU}} "rs1_id"
    read rs2_id {{CPU}} "rs2_id"
    read rd_id {{CPU}} "rd_id"
    read imm {{CPU}} "imm"

    read __etext {{CPU}} "__etext"
    read reservation_set {{CPU}} "reservation_set"
    read privilege_mode {{CPU}} "privilege_mode"
    read effective_privilege_mode {{CPU}} "effective_privilege_mode"

    read UART_FIFO_MODULO {{CPU}} "UART_FIFO_MODULO"
    op sub UART_FIFO_CAPACITY UART_FIFO_MODULO 1

    set addr1 ""
    set pte1 ""
    set addr0 ""
    set pte0 ""
    set trap_cause null

    set address pc
    set mcause 1 # instr access
    jump loop__no_custom_va strictEqual DBG_VIRT_ADDR null
    set address DBG_VIRT_ADDR
    set mcause 5 # load access
loop__no_custom_va:
    
    set mtval address
    set is_address_translation true
    op add ret3 @counter 1
    jump translate_virtual_address lessThan privilege_mode 0b11
    set physical_address address

    set result ""
    set is_address_translation false
    op add ret @counter 1
    jump load_word strictEqual trap_cause null
    set instruction result

    # read AFTER translate_virtual_address
    read mscratch {{CSRS}} "{{ 'mscratch'|csr }}"
    read mtvec {{CSRS}} "{{ 'mtvec'|csr }}"
    read mepc {{CSRS}} "{{ 'mepc'|csr }}"
    read mcause {{CSRS}} "{{ 'mcause'|csr }}"
    read mtval {{CSRS}} "{{ 'mtval'|csr }}"

    # markers

    setmarker remove mark_memory_id
    op add tmp mark_memory_id 1
    setmarker remove tmp
    jump loop__no_mark_program_rom lessThanEq PROGRAM_ROM_SIZE 0

    print "PROGRAM_ROM_START\n{0}"
    set address {{ROM_START}}
    op add ret @counter 1
    jump mark_memory always

    print "PROGRAM_ROM_END\n{0}"
    op sub address PROGRAM_ROM_SIZE 1
    op add ret @counter 1
    jump mark_memory always
loop__no_mark_program_rom:

    setmarker remove mark_memory_id
    op add tmp mark_memory_id 1
    setmarker remove tmp
    jump loop__no_mark_data_rom lessThanEq DATA_ROM_SIZE 0

    print "DATA_ROM_START\n{0}"
    set address PROGRAM_ROM_SIZE
    op add ret @counter 1
    jump mark_memory always

    print "DATA_ROM_END\n{0}"
    op sub address ROM_SIZE 1
    op add ret @counter 1
    jump mark_memory always
loop__no_mark_data_rom:

    print "RAM_START\n{0}"
    set address {{RAM_START}}
    op add ret @counter 1
    jump mark_memory always

    print "RAM_END\n{0}"
    op sub address RAM_END 1
    op add ret @counter 1
    jump mark_memory always

    setmarker remove mark_memory_id
    op add tmp mark_memory_id 1
    setmarker remove tmp
    jump loop__no_mark_icache lessThanEq ICACHE_SIZE 0

    print "ICACHE_START\n{0}"
    set address ICACHE_START
    op add ret @counter 1
    jump mark_memory always

    print "ICACHE_END\n{0}"
    op sub address ICACHE_END 1
    op add ret @counter 1
    jump mark_memory always
loop__no_mark_icache:

    # clear

    draw color 0 0 0 255
    #{ rect(8, 0, 10, 16)
    #{ rect(35, 0, 10, 16)
    #{ rect(60, 0, 10, 16)
    #{ rect(0, 17, 73, 22)
    draw color 255 255 255 255

    # ---- level 1 ----
#% set level_1_row = 0

    # -- column 1 --

    print "{{ '{0}\\n' * 8 }}\n{{ '{0}\\n' * 7 }}"

    set n pc
    op add ret @counter 1
    jump format_hex always

    op add ret2 @counter 1
    jump format_op_id always

    set n satp
    op add ret @counter 1
    jump format_hex always

    set n addr1
    op add ret @counter 1
    jump format_hex_or_empty always

    set n pte1
    op add ret @counter 1
    jump format_hex_or_empty always

    set n addr0
    op add ret @counter 1
    jump format_hex_or_empty always

    set n pte0
    op add ret @counter 1
    jump format_hex_or_empty always

    set n physical_address
    op add ret @counter 2
    jump format_hex_or_empty strictEqual trap_cause null
    jump format_unknown always

    set n instruction
    op add ret @counter 2
    jump format_hex_or_empty strictEqual trap_cause null
    jump format_unknown always

    #{ print(8, level_1_row)

    # -- column 2 --

    print "{{ '{0}\\n' * 16 }}"

    read n {{REGISTERS}} 0
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 1
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 2
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 3
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 4
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 5
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 6
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 7
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 8
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 9
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 10
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 11
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 12
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 13
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 14
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 15
    op add ret @counter 1
    jump format_hex always

    #{ print(35, level_1_row)

    # -- column 3 --

    print "{{ '{0}\\n' * 16 }}"

    read n {{REGISTERS}} 16
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 17
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 18
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 19
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 20
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 21
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 22
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 23
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 24
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 25
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 26
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 27
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 28
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 29
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 30
    op add ret @counter 1
    jump format_hex always

    read n {{REGISTERS}} 31
    op add ret @counter 1
    jump format_hex always

    #{ print(60, level_1_row)

    # ---- level 2 ----
#% set level_2_row = 17

    # -- column 1 --

    print "state           = {0}\n"
    format state

    print "__etext         = {0}\n"
    set n __etext
    op add ret @counter 1
    jump format_hex always

    print "reservation_set = {0}\n"
    set n reservation_set
    op add ret @counter 1
    jump format_hex always

    print "privilege_mode  = {0}\n"
    set n privilege_mode
    op add ret @counter 1
    jump format_privilege_mode always

    print "effective_mode  = {0}\n"
    set n effective_privilege_mode
    op add ret @counter 1
    jump format_privilege_mode always

    #{ print(0, level_2_row)

    # ---- level 3 ----
#% set level_3_row = 23

    # -- column 1 --

    print "mtvec    = {0}\n"
    set n mtvec
    op add ret @counter 1
    jump format_hex always

    print "mepc     = {0}\n"
    set n mepc
    op add ret @counter 1
    jump format_hex always

    print "mcause   = {0}\n"
    set n mcause
    op add ret @counter 1
    jump format_mcause always

    print "mtval    = {0}\n"
    set n mtval
    op add ret @counter 1
    jump format_hex always

    print "mscratch = {0}\n\n"
    set n mscratch
    op add ret @counter 1
    jump format_hex always

    print "mstatus  = {0}\n"
    set n mstatus
    op add ret @counter 1
    jump format_bin always

    print "mip      = {0}\n"
    set n mip
    op add ret @counter 1
    jump format_bin always

    print "mie      = {0}\n"
    set n mie
    op add ret @counter 1
    jump format_bin always

    #{ print(0, level_3_row)

    # -- column 2 --

    print "stvec    = {0}\n"
    set n stvec
    op add ret @counter 1
    jump format_hex always

    print "sepc     = {0}\n"
    set n sepc
    op add ret @counter 1
    jump format_hex always

    print "scause   = {0}\n"
    set n scause
    op add ret @counter 1
    jump format_mcause always

    print "stval    = {0}\n"
    set n stval
    op add ret @counter 1
    jump format_hex always

    print "sscratch = {0}\n"
    set n sscratch
    op add ret @counter 1
    jump format_hex always

    #{ print(35, level_3_row)

    # ---- level 4 ----
#% set level_4_row = 33

    # -- column 1 --

    print "mtimecmp = {0}\n"
    format mtimecmp

    print "mtime    = {0}\n"
    format mtime

    print "mcycle   = {0}\n"
    format mcycle

    print "minstret = {0}\n"
    format minstret

    #{ print(0, level_4_row)

    # -- column 2 --

    set uart {{UART0}}
    set uart_index 0
    op add ret @counter 1
    jump format_uart always

    set uart {{UART1}}
    set uart_index 1
    op add ret @counter 1
    jump format_uart always

    set uart {{UART2}}
    set uart_index 2
    op add ret @counter 1
    jump format_uart always

    set uart {{UART3}}
    set uart_index 3
    op add ret @counter 1
    jump format_uart always

    #{ print(30, level_4_row)

    wait 0.02
    jump loop always

format_hex_or_empty:
    jump format_unknown strictEqual n ""
format_hex:
    jump format_null strictEqual n null
    op floor n n
    op and n n 0xffffffff # in case we get a negative value
format_hex__loop:
    op mod digit n 16
    op mul skip digit 2
    op add @counter @counter skip
    format "{0}0"
    jump format_hex__next always
    format "{0}1"
    jump format_hex__next always
    format "{0}2"
    jump format_hex__next always
    format "{0}3"
    jump format_hex__next always
    format "{0}4"
    jump format_hex__next always
    format "{0}5"
    jump format_hex__next always
    format "{0}6"
    jump format_hex__next always
    format "{0}7"
    jump format_hex__next always
    format "{0}8"
    jump format_hex__next always
    format "{0}9"
    jump format_hex__next always
    format "{0}A"
    jump format_hex__next always
    format "{0}B"
    jump format_hex__next always
    format "{0}C"
    jump format_hex__next always
    format "{0}D"
    jump format_hex__next always
    format "{0}E"
    jump format_hex__next always
    format "{0}F"
format_hex__next:
    op shr n n 4
    jump format_hex__loop greaterThan n 0
    format "0x"
    set @counter ret

format_bin:
    jump format_null strictEqual n null
    set i 0
    op floor n n
    op and n n 0xffffffff
format_bin__loop:
    op mod digit n 2
    op mul skip digit 2
    op add @counter @counter skip
    format "{0}0"
    jump format_bin__next always
    format "{0}1"
format_bin__next:
    op shr n n 1
    op add i i 1
    jump format_bin__loop lessThan i 32
    format "0b"
    set @counter ret

# format order: op_id, imm, rs1, rs2, rd
format_op_id:
    jump format_op_id__unknown strictEqual op_id null
    jump format_op_id__unknown lessThan op_id -64
    jump format_op_id__unknown greaterThan op_id 1
    op add jump op_id 64
    op mul jump jump 2
    op add @counter @counter jump
    format "BEQ";           jump format_op_id__B-type always
    format "BNE";           jump format_op_id__B-type always
    format "JAL";           jump format_op_id__J-type always
    format "JALR";          jump format_op_id__I-type always
    format "BLT";           jump format_op_id__B-type always
    format "BGE";           jump format_op_id__B-type always
    format "BLTU";          jump format_op_id__B-type always
    format "BGEU";          jump format_op_id__B-type always
    format "LB";            jump format_op_id__I-type always
    format "LH";            jump format_op_id__I-type always
    format "LW";            jump format_op_id__I-type always
    format "LUI";           jump format_op_id__U-type always
    format "LBU";           jump format_op_id__I-type always
    format "LHU";           jump format_op_id__I-type always
    format "SB";            jump format_op_id__S-type always
    format "SH";            jump format_op_id__S-type always
    format "SW";            jump format_op_id__S-type always
    format "AMOADD.W";      jump format_op_id__R-type always
    format "AMOSWAP.W";     jump format_op_id__R-type always
    format "LR.W";          jump format_op_id__R-type always
    format "SC.W";          jump format_op_id__R-type always
    format "AMOXOR.W";      jump format_op_id__R-type always
    format "AMOOR.W";       jump format_op_id__R-type always
    format "AMOAND.W";      jump format_op_id__R-type always
    format "AMOMIN.W";      jump format_op_id__R-type always
    format "AMOMAX.W";      jump format_op_id__R-type always
    format "AMOMINU.W";     jump format_op_id__R-type always
    format "AMOMAXU.W";     jump format_op_id__R-type always
    format "ADDI";          jump format_op_id__I-type always
    format "SUB";           jump format_op_id__R-type always
    format "SLTI";          jump format_op_id__I-type always
    format "SLTIU";         jump format_op_id__I-type always
    format "XORI";          jump format_op_id__I-type always
    format "SRA";           jump format_op_id__R-type always
    format "ORI";           jump format_op_id__I-type always
    format "ANDI";          jump format_op_id__I-type always
    format "ADD";           jump format_op_id__R-type always
    format "SLL";           jump format_op_id__R-type always
    format "SLT";           jump format_op_id__R-type always
    format "SLTU";          jump format_op_id__R-type always
    format "XOR";           jump format_op_id__R-type always
    format "SRL";           jump format_op_id__R-type always
    format "OR";            jump format_op_id__R-type always
    format "AND";           jump format_op_id__R-type always
    format "MUL";           jump format_op_id__R-type always
    format "MULH";          jump format_op_id__R-type always
    format "MULHSU";        jump format_op_id__R-type always
    format "MULHU";         jump format_op_id__R-type always
    format "DIV";           jump format_op_id__R-type always
    format "DIVU";          jump format_op_id__R-type always
    format "REM";           jump format_op_id__R-type always
    format "REMU";          jump format_op_id__R-type always
    jump format_op_id__priv always; stop
    format "CSRRW";         jump format_op_id__I-type always
    format "CSRRS";         jump format_op_id__I-type always
    format "CSRRC";         jump format_op_id__I-type always
    format "AUIPC";         jump format_op_id__U-type always
    format "CSRRWI";        jump format_op_id__I-type always
    format "CSRRSI";        jump format_op_id__I-type always
    format "CSRRCI";        jump format_op_id__I-type always
    format "FENCE";         jump format_op_id__I-type always
    format "SLLI";          jump format_op_id__I-type always
    format "SRLI";          jump format_op_id__I-type always
    format "SRAI";          jump format_op_id__I-type always
    format "ILLEGAL_OP";    jump format_op_id__empty always
    format "MLOGSYS";       jump format_op_id__I-type always

format_op_id__priv:
    op shr funct7 imm 5
    set name "ECALL";       jump format_op_id__priv__ok equal imm 0b000000000000
    set name "EBREAK";      jump format_op_id__priv__ok equal imm 0b000000000001
    set name "SRET";        jump format_op_id__priv__ok equal imm 0b000100000010
    set name "MRET";        jump format_op_id__priv__ok equal imm 0b001100000010
    set name "WFI";         jump format_op_id__priv__ok equal imm 0b000100000101
    set name "SFENCE.VMA";  jump format_op_id__priv__ok equal funct7 0b0001001
    jump format_op_id__unknown always
format_op_id__priv__ok:
    format name
    jump format_op_id__I-type always

#% macro format_conditional(cond, n)
#% if cond
#{ caller()
#% else
#% for _ in range(n)
    format ""
#% endfor
#% endif
#% endmacro

#% macro format_op_args(imm, rs1, rs2, rd)
#% call format_conditional(imm, 1)
    set n imm
    op add ret @counter 1
    jump format_hex always
#% endcall
#% call format_conditional(rs1, 2)
    format rs1_id
    read n {{REGISTERS}} rs1_id
    op add ret @counter 1
    jump format_hex always
#% endcall
#% call format_conditional(rs2, 2)
    format rs2_id
    read n {{REGISTERS}} rs2_id
    op add ret @counter 1
    jump format_hex always
#% endcall
#% call format_conditional(rd, 1)
    format rd_id
#% endcall
#% endmacro

format_op_id__unknown:
    format op_id
#{ format_op_args(imm=true, rs1=true, rs2=true, rd=true)
    set @counter ret2

format_op_id__empty:
#{ format_op_args(imm=false, rs1=false, rs2=false, rd=false)
    set @counter ret2

format_op_id__R-type:
#{ format_op_args(imm=false, rs1=true, rs2=true, rd=true)
    set @counter ret2

format_op_id__I-type:
#{ format_op_args(imm=true, rs1=true, rs2=false, rd=true)
    set @counter ret2

format_op_id__S-type:
#{ format_op_args(imm=true, rs1=true, rs2=true, rd=false)
    set @counter ret2

format_op_id__B-type:
#{ format_op_args(imm=true, rs1=true, rs2=true, rd=false)
    set @counter ret2

format_op_id__U-type:
format_op_id__J-type:
#{ format_op_args(imm=true, rs1=false, rs2=false, rd=true)
    set @counter ret2

format_unknown:
    format n
    set @counter ret

format_null:
    format "null"
    set @counter ret

# uart, uart_index ->
format_uart:
    read rx_rptr uart 254
    read rx_wptr_raw uart 255
    read tx_rptr uart 510
    read tx_wptr uart 511

    op and rx_wptr rx_wptr_raw 0xff

    op sub rx_fifo_size rx_wptr rx_rptr
    op add rx_fifo_size rx_fifo_size UART_FIFO_MODULO
    op mod rx_fifo_size rx_fifo_size UART_FIFO_MODULO

    op sub tx_fifo_size tx_wptr tx_rptr
    op add tx_fifo_size tx_fifo_size UART_FIFO_MODULO
    op mod tx_fifo_size tx_fifo_size UART_FIFO_MODULO

    op equal rx_full rx_fifo_size UART_FIFO_CAPACITY
    op notEqual rx_overflow_flag rx_wptr rx_wptr_raw
    op land rx_overrun rx_full rx_overflow_flag

    print "uart{0}: rx={1}"
    jump format_uart__rx_fifo_size__no_overrun notEqual rx_overrun true
    print "!"
    jump format_uart__rx_fifo_size__no_overrun__done always
format_uart__rx_fifo_size__no_overrun:
    print " "
format_uart__rx_fifo_size__no_overrun__done:
    print "({2}-{3}) tx={4} ({5}-{6})\n"

    format uart_index
    format rx_fifo_size
    format rx_rptr
    format rx_wptr
    format tx_fifo_size
    format tx_rptr
    format tx_wptr

    set @counter ret

format_mcause:
    jump format_mcause__reset strictEqual n null
    jump format_mcause__interrupt greaterThanEq n 0x80000000
    jump format_hex greaterThan n 19
    op mul jump n 2
    op add @counter @counter jump
    format "instr_misalign"; set @counter ret
    format "instr_access_fault"; set @counter ret
    format "illegal_instr"; set @counter ret
    format "breakpoint"; set @counter ret
    format "load_misalign"; set @counter ret
    format "load_access_fault"; set @counter ret
    format "store/AMO_misalign"; set @counter ret
    format "store/AMO_access_fault"; set @counter ret
    format "ecall_from_U-mode"; set @counter ret
    format "ecall_from_S-mode"; set @counter ret
    jump format_hex always; stop
    format "ecall_from_M-mode"; set @counter ret
    format "instr_page_fault"; set @counter ret
    format "load_page_fault"; set @counter ret
    jump format_hex always; stop
    format "store/AMO_page_fault"; set @counter ret
    jump format_hex always; stop
    jump format_hex always; stop
    format "software_check"; set @counter ret
    format "hardware_check"; set @counter ret

format_mcause__reset:
    format "reset"
    set @counter ret

format_mcause__interrupt:
    op and n2 n 0x7fffffff
    op mod rem n2 2
    jump format_hex notEqual rem 1
    jump format_hex greaterThan n2 13
    op sub jump n2 1
    op add @counter @counter jump
    format "S_software_int"; set @counter ret
    format "M_software_int"; set @counter ret
    format "S_timer_int"; set @counter ret
    format "M_timer_int"; set @counter ret
    format "S_external_int"; set @counter ret
    format "M_external_int"; set @counter ret
    format "cntr_overflow_int"; set @counter ret

format_privilege_mode:
    jump format_null strictEqual n null
    jump format_unknown lessThan n 0b00
    jump format_unknown greaterThan n 0b11
    op mul jump n 2
    op add @counter @counter jump
    format "user"; set @counter ret
    format "supervisor"; set @counter ret
    format "reserved"; set @counter ret
    format "machine"; set @counter ret

# creates a marker on the ram proc containing a given address
# the caller should print a format string with a placeholder for the address
# address ->
mark_memory:
    set mark_memory__ret ret

    jump mark_memory__rom lessThan address {{RAM_START}}

    op sub _address address {{RAM_START}}

    # we store 4 bytes in each value
    op idiv _address _address 4

    # get the ram proc containing this address
    op idiv _ram_index _address {{RAM_PROC_VARS}}
    op add _ram_index _ram_index RAM_START_PROC

    op mod x _ram_index MEMORY_WIDTH
    op add x x MEMORY_X

    op idiv y _ram_index MEMORY_WIDTH
    op add y y MEMORY_Y

    jump mark_memory__found always

mark_memory__rom:
    # get rom proc data
    op idiv _rom_index address {{ROM_PROC_BYTES}}

    op mod x _rom_index MEMORY_WIDTH
    op add x x MEMORY_X

    op idiv y _rom_index MEMORY_WIDTH
    op add y y MEMORY_Y

mark_memory__found:
    set n address
    op add ret @counter 1
    jump format_hex always

    setmarker remove mark_memory_id
    makemarker shapeText mark_memory_id x y false

    op sub layer 120 mark_memory_id
    op add layer layer MARKER_START_ID
    setmarker drawLayer mark_memory_id layer

    setmarker radius mark_memory_id 3
    setmarker textHeight mark_memory_id 0.5
    setmarker fontSize mark_memory_id 0.9

    setmarker flushText mark_memory_id false

    op add mark_memory_id mark_memory_id 1
    set @counter mark_memory__ret

# apply Sv32 virtual address translation
# jumps to this function must be conditional on privilege_mode or effective_privilege_mode
# address is assumed to already be truncated to 32 bits
# mcause must contain the access fault code for the original access type (ie. 1, 5, or 7)
# mtval must contain the same value as address
# address, mcause, mtval -> address
# ret: ret3
# clobbers: locals, nonlocal2
translate_virtual_address:
    # if this function is called, we know that the current effective privilege mode permits address translation
    # so the only thing we need to check here is satp.MODE
    jump translate_virtual_address__unchanged lessThan satp 0x80000000

    # begin virtual address translation algorithm
    # PAGESIZE=2^12, LEVELS=2, PTESIZE=4
    
    # step 1

    # a = satp.ppn * PAGESIZE
#%# do reset_locals()
    op and $a satp 0x3fffff # satp.ppn
    op mul $a $a {{PAGESIZE}}
    # i = LEVELS - 1 = 1
    # nonlocal2 = (i + 1) * 10
    # i is stored in this form because it simplifies step 2 and doesn't really matter for other steps
    # we use nonlocal2 because amo uses nonlocal1
    set nonlocal2 20 # i=1

    # step 2
translate_virtual_address__step_2:

    # pte = load(a + va.vpn[i] * PTESIZE)
    #     = load(a + (va.vpn[i] << 2))
    #     = load(a + (va[y:x] << 2))
    #     = load(a + (va >> (x - 2))[11:2])
    op shr address mtval nonlocal2
    op and address address 0b111111111100
    op add address address $a

    jump translate_virtual_address__step_2__debug_addr0 equal nonlocal2 10
    set addr1 address
    jump translate_virtual_address__step_2__debug_addr_done always
translate_virtual_address__step_2__debug_addr0:
    set addr0 address
translate_virtual_address__step_2__debug_addr_done:

    op add ret @counter 1
    jump load_word always
    # result = pte

    jump translate_virtual_address__step_2__debug_pte0 equal nonlocal2 10
    set pte1 result
    jump translate_virtual_address__step_2__debug_pte_done always
translate_virtual_address__step_2__debug_pte0:
    set pte0 result
translate_virtual_address__step_2__debug_pte_done:

    # step 3

    # if pte is not a pointer, we check pte.a here instead of step 7
    # so pte is invalid if v=0, or if r=0 and w=1, or if (r=1 or x=1) and a=0

    # a00xwrv

    # a | x | w | r | v | index | valid?
    # - | - | - | - | - | ----- | --------
    # 0 | 0 | 0 | 0 | 0 | 0     | no (v=0)
    # 0 | 0 | 0 | 0 | 1 | 1     | yes
    # 0 | 0 | 0 | 1 | 0 | 2     | no (v=0)
    # 0 | 0 | 0 | 1 | 1 | 3     | no (a=0)
    # 0 | 0 | 1 | 0 | 0 | 4     | no (v=0)
    # 0 | 0 | 1 | 0 | 1 | 5     | no (a=0)
    # 0 | 0 | 1 | 1 | 0 | 6     | no (v=0)
    # 0 | 0 | 1 | 1 | 1 | 7     | no (a=0)
    # 0 | 1 | 0 | 0 | 0 | 8     | no (v=0)
    # 0 | 1 | 0 | 0 | 1 | 9     | no (a=0)
    # 0 | 1 | 0 | 1 | 0 | 10    | no (v=0)
    # 0 | 1 | 0 | 1 | 1 | 11    | no (a=0)
    # 0 | 1 | 1 | 0 | 0 | 12    | no (v=0)
    # 0 | 1 | 1 | 0 | 1 | 13    | no (a=0)
    # 0 | 1 | 1 | 1 | 0 | 14    | no (v=0)
    # 0 | 1 | 1 | 1 | 1 | 15    | no (a=0)
    # 1 | 0 | 0 | 0 | 0 | 64    | no (v=0)
    # 1 | 0 | 0 | 0 | 1 | 65    | yes
    # 1 | 0 | 0 | 1 | 0 | 66    | no (v=0)
    # 1 | 0 | 0 | 1 | 1 | 67    | yes
    # 1 | 0 | 1 | 0 | 0 | 68    | no (v=0)
    # 1 | 0 | 1 | 0 | 1 | 69    | no (r=0)
    # 1 | 0 | 1 | 1 | 0 | 70    | no (v=0)
    # 1 | 0 | 1 | 1 | 1 | 71    | yes
    # 1 | 1 | 0 | 0 | 0 | 72    | no (v=0)
    # 1 | 1 | 0 | 0 | 1 | 73    | yes
    # 1 | 1 | 0 | 1 | 0 | 74    | no (v=0)
    # 1 | 1 | 0 | 1 | 1 | 75    | yes
    # 1 | 1 | 1 | 0 | 0 | 76    | no (v=0)
    # 1 | 1 | 1 | 0 | 1 | 77    | no (r=0)
    # 1 | 1 | 1 | 1 | 0 | 78    | no (v=0)
    # 1 | 1 | 1 | 1 | 1 | 79    | yes

#% set valid_indices = [1, 65, 67, 71, 73, 75, 79]

#%# do reset_locals()
    op and $a_x_w_r_v result 0b1001111
    read $valid "{% for i in range(80) %}{{ (i in valid_indices)|int }}{% endfor %}" $a_x_w_r_v
    jump translate_virtual_address__page_fault notEqual $valid 49 # ascii 1

    # step 4

    # if pte.r=1 or pte.x=1, this is a leaf PTE
    op and $x_r result 0b1010
    jump translate_virtual_address__step_5 notEqual $x_r 0

    # otherwise, if nonlocal2 has been updated, then i-1 < 0, so raise a page fault exception
    jump translate_virtual_address__page_fault notEqual nonlocal2 20

    # otherwise, let a=pte.ppn * PAGESIZE, let i=i-1, and go to step 2
#%# do reset_locals()
    op and $a result 0xfffffc00
    op shl $a $a 2
    set nonlocal2 10 # i=0
    jump translate_virtual_address__step_2 always

    # step 5
translate_virtual_address__step_5:

    # effective_privilege_mode is either S (1) or U (0)

    # SUCCEED IF
    
    # execute:
    #   x == 1
    #   && (effective_privilege_mode == U ? u == 1 : u == 0)

    # load:
    #   (r == 1 || MXR == 1 && x == 1)
    #   && (effective_privilege_mode == U ? u == 1 : (u == 0 || SUM == 1))

    # store:
    #   w == 1
    #   && (effective_privilege_mode == U ? u == 1 : (u == 0 || SUM == 1))

    # FAIL IF

    # execute:
    #   x == 0
    #   || u == 0 && effective_privilege_mode == 0
    #   || u == 1 && effective_privilege_mode == 1
    # load:
    #   r == 0 && (MXR == 0 || x == 0)
    #   || u == 0 && effective_privilege_mode == 0
    #   || u == 1 && effective_privilege_mode == 1 && SUM == 0
    # store:
    #   w == 0
    #   || u == 0 && effective_privilege_mode == 0
    #   || u == 1 && effective_privilege_mode == 1 && SUM == 0

    # prevent user mode from accessing non-user pages
#%# do reset_locals()
    op and $u_priv result 0b10000
    op or $u_priv $u_priv effective_privilege_mode
    jump translate_virtual_address__page_fault equal $u_priv 0

    # prevent supervisor mode from executing user pages
    jump translate_virtual_address__step_5__execute equal mcause 1 # execute

    # prevent supervisor mode from reading/writing user pages if mstatus.SUM is not set
    op and $mstatus.sum mstatus 0b1000000000000000000
    jump translate_virtual_address__step_5__sum notEqual $mstatus.sum 0

translate_virtual_address__step_5__execute:
    jump translate_virtual_address__page_fault equal $u_priv 0b10001
translate_virtual_address__step_5__sum:

    # check if the required rwx bits are set

    # PTE: ...daguxwrv
    # if we mask off g and u, we can use ASCII characters 0b0011___0

    # type    | mcause | MXR | PTE mask || index | char
    # ------- | ------ | --- | -------- || ----- | ----
    # execute | 1      | 0   | 0b1000   || 1     | '8' (0011 1000)
    # execute | 1      | 1   | 0b1000   || 2     | '8' (0011 1000)
    # load    | 5      | 0   | 0b0010   || 5     | '2' (0011 0010)
    # load    | 5      | 1   | 0b1010   || 6     | ':' (0011 1010)
    # store   | 7      | 0   | 0b0100   || 7     | '4' (0011 0100)
    # store   | 7      | 1   | 0b0100   || 8     | '4' (0011 0100)

    # extract fields from PTE
    # this value is also used in step 7
#%# do reset_locals()
    # ------- DO NOT RESET LOCALS AFTER THIS LINE -------
    op and $d_x_w_r result 0b10001110

    # extract MXR bit
    op shr $mstatus.mxr mstatus 19
    op and $mstatus.mxr $mstatus.mxr 0b1

    # fetch the bitmask from the string as per the above table
    op add $mask mcause $mstatus.mxr
    read $mask "_88__2:44" $mask

    # fail if NONE of the required bits are set in pte
    # this is fine because none of the things we're checking here require more than one bit to be set
    # in particular, if MXR is 1, loads succeed if r is 1 OR x is 1
    op and $mask $d_x_w_r $mask
    jump translate_virtual_address__page_fault equal $mask 0

    # step 6

    # skip this step if i == 0
    # nonlocal2 == (i + 1) * 10
    jump translate_virtual_address__step_7 equal nonlocal2 10

    # if i > 0 and pte.ppn[i-1:0] != 0, this is a misaligned superpage
    # in Sv32, i is either 1 or 0
    # so we need to check pte.ppn[0]

    op and $pte.ppn[0] result 0xffc00
    jump translate_virtual_address__page_fault notEqual $pte.ppn[0] 0

    # step 7
translate_virtual_address__step_7:

    # we implement Svade for this step because it's simpler
    # if pte.a=0, or if the original memory access is a store and pte.d=0, raise a page fault exception

    # pte.a was checked in step 3

    # fault if storing and pte.d=0
    jump translate_virtual_address__step_8 notEqual mcause 7 # store/AMO
    jump translate_virtual_address__page_fault lessThan $d_x_w_r 0b10000000
    # ------- end critical locals section -------

    # step 8
translate_virtual_address__step_8:

    # move the pte.ppn fields into position
    op shl result result 2

    # raise an access fault exception if the resulting physical address will be wider than 32 bits
    # TODO: is there any case where we *don't* want to do this?
    jump trap greaterThan result 0xffffffff

    # if i>0, this is a superpage
    jump translate_virtual_address__step_8__superpage greaterThan nonlocal2 10

    # pa.pgoff = va.pgoff
    op and address mtval 0xfff
    
    # pa.ppn = pte.ppn
    op and result result 0xfffff000
    op or address address result

    set @counter ret3

translate_virtual_address__step_8__superpage:
    # pa.pgoff = va.pgoff
    # pa.ppn[0] = va.ppn[0]
    op and address mtval 0x3fffff

    # pa.ppn[1] = pte.ppn[1]
    op and result result 0xffc00000
    op or address address result

translate_virtual_address__unchanged:
    set @counter ret3

translate_virtual_address__page_fault:
    # we need to convert mcause from access fault to page fault
    # instruction: 1 -> 12
    # load:        5 -> 13
    # store/AMO:   7 -> 15
    # for load/store/AMO, page fault = access fault + 8
    # for instruction, 1 + 8 = 9 < 12 < 13 < 15
    # instruction: max(1 + 8, 12) = max(9, 12)  = 12
    # load:        max(5 + 8, 12) = max(13, 12) = 13
    # store/AMO:   max(7 + 8, 12) = max(15, 12) = 15
    op add mcause mcause 8
    op max mcause mcause 12
    jump trap always

# helper function to find the ram proc and variable for a given address
# address -> ram, variable
# ret: ret2
access_ram:
#%# do reset_locals()
    # _address is named because it's also an input for lookup_variable
    op sub _address address {{RAM_START}}

# _address -> ram, variable
    # we store 4 bytes in each value
    op idiv _address _address 4

    # get the ram proc containing this address
    op idiv $ram_index _address {{RAM_PROC_VARS}}
    op add $ram_index $ram_index RAM_START_PROC

    op mod $ram_x $ram_index MEMORY_WIDTH
    op add $ram_x $ram_x MEMORY_X

    op idiv $ram_y $ram_index MEMORY_WIDTH
    op add $ram_y $ram_y MEMORY_Y

    getblock building ram $ram_x $ram_y

    # get the variable within the ram proc containing this address
    op mod _address _address {{RAM_PROC_VARS}}

# given a value 0 <= _address < RAM_PROC_VARS, resolve that variable in the lookup table
# this must stay directly after access_ram
# _address -> variable
# ret: ret2
# NOTE: modify_csr assumes this function uses one local
#%# do reset_locals()
    # the lookup is assumed to start at link 0, so we don't need to add an offset here
    op idiv $lookup _address {{LOOKUP_PROC_SIZE}}
    getlink $lookup $lookup

    op mod variable _address {{LOOKUP_PROC_SIZE}}
    lookup block variable variable
    sensor variable variable @name
    read variable $lookup variable

    set @counter ret2

# loads the word from memory that contains the specified address
# mcause is required in order to raise the correct exception in case of access fault
# address, mcause, mtval -> result
# ret: ret
# clobbers: locals, ret2, value
load_word:
    jump load_rom_word_unchecked lessThan address ROM_SIZE

    jump trap greaterThanEq address {{MMIO_START}}

    jump trap lessThan address {{RAM_START}}
    jump trap greaterThanEq address RAM_END
    # continue into load_ram_word_unchecked

    # locate and read value from ram
    op add ret2 @counter 1
    jump access_ram always
    read value ram variable
    # null is coerced to 0 by swap_endianness

    # tail call, swap_endianness will jump to the ret value of load_word's caller

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# this MUST stay directly after load_word
# value -> result
#%# do reset_locals()
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl $tmp value 8
    op and $tmp $tmp 0xff0000
    op or result result $tmp

    # byte 2 -> byte 1
    op shr $tmp value 8
    op and $tmp $tmp 0xff00
    op or result result $tmp

    # byte 0 -> byte 3
    op shl $tmp value 24
    op and $tmp $tmp 0xff000000
    op or result result $tmp

    set @counter ret

# loads a word from ROM
# address -> result
load_rom_word_unchecked:
#%# do reset_locals()
    # align to 4 bytes
    op and $address address 0xfffffffc

    # get rom proc data
    op idiv $rom_index $address {{ROM_PROC_BYTES}}
    op mod $str_index $address {{ROM_PROC_BYTES}}

    op mod $rom_x $rom_index MEMORY_WIDTH
    op add $rom_x $rom_x MEMORY_X

    op idiv $rom_y $rom_index MEMORY_WIDTH
    op add $rom_y $rom_y MEMORY_Y

    getblock building _rom $rom_x $rom_y
    read _rom _rom "v"

    # read bytes of word
    read $byte0 _rom $str_index

    op add $str_index $str_index 1
    read $byte1 _rom $str_index

    op add $str_index $str_index 1
    read $byte2 _rom $str_index

    op add $str_index $str_index 1
    read _rom _rom $str_index # clear _rom to avoid issues with the vars menu and block data size

    # merge into big endian
    op shl $byte1 $byte1 8
    op shl $byte2 $byte2 16
    op shl _rom _rom 24

    op add result $byte0 $byte1
    op add result result $byte2
    op add result result _rom

    op sub result result {{# ROM_BYTE_OFFSET * (1 + 2**8 + 2**16 + 2**24) }}
    op max result result 0 # if we're reading out of bounds, default to 0
    
    set @counter ret

trap:
    set trap_cause "misalign"
    jump trap__found_cause equal mcause 0
    set trap_cause "access_flt"
    jump trap__found_cause equal mcause 1
    set trap_cause "page_flt"
    jump trap__found_cause equal mcause 12
    set trap_cause mcause
trap__found_cause:

    jump trap__translate equal is_address_translation true
    set result trap_cause
    set @counter ret

trap__translate:
    set address trap_cause
    set @counter ret3

#% if false
# {% raw %}
set {{ null
set {{LOOKUP_PROC_SIZE}} null
set {{ROM_PROC_BYTES}} null
set {{RAM_PROC_VARS}} null
set {{ROM_START}} null
set {{RAM_START}} null
set {{MMIO_START}} null
set {{PAGESIZE}} null
set {{CPU}} null
set {{CSRS}} null
set {{REGISTERS}} null
set {{DISPLAY}} null
set {{SWITCH}} null
set {{UART0}} null
set {{UART1}} null
set {{UART2}} null
set {{UART3}} null
# {% endraw %}
#% endif
