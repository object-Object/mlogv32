#%# hack: use extends so we don't need to individually import all of the constants
#% extends 'main.constants.jinja'
#% block contents

reset:
    set STATE "reset" # for debug output

    # load config
    read MEMORY_X {{CONFIG}} "MEMORY_X"
    read MEMORY_Y {{CONFIG}} "MEMORY_Y"
    read MEMORY_WIDTH {{CONFIG}} "MEMORY_WIDTH"
    read ROM_SIZE {{CONFIG}} "ROM_SIZE"
    read RAM_SIZE {{CONFIG}} "RAM_SIZE"
    read ICACHE_SIZE {{CONFIG}} "ICACHE_SIZE"

    op idiv RAM_START_PROC ROM_SIZE {{ROM_PROC_BYTES}}

    op add RAM_END {{RAM_START}} RAM_SIZE

    op idiv ICACHE_START_VAR RAM_SIZE 4

    # loop until the reset switch is linked and disabled
    jump reset strictEqual {{RESET_SWITCH}} null
    sensor enabled {{RESET_SWITCH}} @enabled
    jump reset equal enabled true

    # initialization

    op add ret @counter 1
    jump reload_config always

    # initialize peripherals
    control enabled {{PAUSE_SWITCH}} false

    printflush {{ERROR_OUTPUT}}

    draw clear 0 0 0
    drawflush {{DISPLAY}}

    read kbconv_rptr {{KBCONV_DATA}} 63

    # read initial CSR values
    read minstret {{CSRS}} "{{ 'minstret'|csr }}"
    read minstreth {{CSRS}} "{{ 'minstreth'|csr }}"

    # reset time/cycle reference point
    set last_time_update @time
    set last_cycle_update @tick
    set next_time_update @time

    # reset icache
    set icache_var null
    set __etext 0

    # reset mtvec to implementation-defined value to help catch bugs
    write {{DEFAULT_MTVEC}} {{CSRS}} "{{ 'mtvec'|csr }}"

    # reset hart state as per machine-level ISA

    # set privilege mode to M
    set privilege_mode 0b11

    # reset MIE and MPRV to 0
    read mstatus {{CSRS}} "{{ 'mstatus'|csr }}"
    # MPRV                                 -
    # MIE                                                -
    op and mstatus mstatus 0b11111111111111011111111111110111
    write mstatus {{CSRS}} "{{ 'mstatus'|csr }}"
    
    # set pc to reset vector
    set pc 0

    # set mcause to 0, since we don't distinguish different reset conditions
    write 0 {{CSRS}} "{{ 'mcause'|csr }}"
    
    # clear LR/SC reservation set
    set reservation_set null

    set STATE "running"

main:
    jump main__skip_time_update lessThan @time next_time_update

    # update time
    # TODO: handle mtimeh/mcycleh overflow
    op sub delta_ms @time last_time_update

    op add mtime mtime delta_ms
    op floor mtime mtime

    op shr mtime_overflow mtime 32
    op add mtimeh mtimeh mtime_overflow

    op mod mtime mtime 0x100000000

    write mtime {{CSRS}} "{{ 'time'|csr }}"
    write mtimeh {{CSRS}} "{{ 'timeh'|csr }}"

    # update cycle
    # we define the rate of increase of cycle as "@ipt * ticks"
    # this should be a decent estimation of the number of mlog instructions executed
    op sub delta_cycles @tick last_cycle_update
    op mul delta_cycles delta_cycles @ipt

    op add mcycle mcycle delta_cycles
    op floor mcycle mcycle

    op shr mcycle_overflow mcycle 32
    op add mcycleh mcycleh mcycle_overflow

    op mod mcycle mcycle 0x100000000

    write mcycle {{CSRS}} "{{ 'mcycle'|csr }}"
    write mcycle {{CSRS}} "{{ 'cycle'|csr }}"
    write mcycleh {{CSRS}} "{{ 'mcycleh'|csr }}"
    write mcycleh {{CSRS}} "{{ 'cycleh'|csr }}"

    set last_time_update @time
    set last_cycle_update @tick
    op add next_time_update @time 1

    # check if interrupts should be pending
    # we do this in time_update because interrupts are either caused by mtime(h) incrementing or an external event
    # and time_update is effectively only called when the processor has crossed an IPT boundary
    
    # timer interrupt
    op greaterThan mtimeh_gt_mtimecmph mtimeh mtimecmph
    op equal mtimeh_eq_mtimecmph mtimeh mtimecmph
    op greaterThanEq mtime_ge_mtimecmp mtime mtimecmp

    op and mip.mtip mtimeh_eq_mtimecmph mtime_ge_mtimecmp
    op or mip.mtip mip.mtip mtimeh_gt_mtimecmph
    op shl mip.mtip mip.mtip 7

    read mip {{CSRS}} "{{ 'mip'|csr }}"
    op and mip mip 0b11111111111111111111111101111111
    op or mip mip mip.mtip
    write mip {{CSRS}} "{{ 'mip'|csr }}"

    # check if interrupts should fire

    jump main__interrupts_user_mode lessThan privilege_mode 0b11
    op and mstatus.mie mstatus 0b1000
    jump main__skip_interrupts equal mstatus.mie 0
main__interrupts_user_mode:

    # timer interrupt
    read mie {{CSRS}} "{{ 'mie'|csr }}"
    op and mie.mtie mie mip.mtip
    set mcause 0x80000007 # machine timer interrupt
    set mtval 0
    jump trap notEqual mie.mtie 0

main__skip_interrupts:
main__skip_time_update:

    set mtval pc

    # get the current instruction cache processor and variable
    jump main__read_icache notEqual icache_var null

    # fall back to slow instruction fetch/decode if not in valid icache range
    # note: MLOGSYS enforces __etext <= ICACHE_SIZE and __etext <= ROM_SIZE
    jump main__access_icache lessThan pc __etext
    jump main__slow_instruction_fetch lessThan pc ROM_SIZE
    jump main__access_icache lessThan pc ICACHE_SIZE

main__slow_instruction_fetch:
    jump default_mtvec_handler equal pc {{DEFAULT_MTVEC}}

    set mcause 1 # instruction access fault
    jump trap greaterThanEq pc RAM_END # prevent executing from MMIO

    set address pc
    op add ret @counter 1
    jump load_word always

    set instruction result
    set decode_address null
    
    # IMPORTANT: remember to update this value if anything in access_icache or read_icache is changed
    op add decode_ret @counter 14
    jump decode always

main__access_icache:
    op add _address ICACHE_START_VAR pc
    op add access_ram__ret @counter 1
    jump access_ram_raw always
    set icache_ram ram
    set icache_var variable
    # load instruction and arguments
main__read_icache:
    read op_id icache_ram icache_var
    read icache_var {{INCR}} icache_var
    read arg1 icache_ram icache_var
    read icache_var {{INCR}} icache_var
    read arg2 icache_ram icache_var
    read icache_var {{INCR}} icache_var
    read arg3 icache_ram icache_var
    read icache_var {{INCR}} icache_var

    # read rs1 and rs2
    # this wastes 1 cycle for I-type and 2 cycles for U-type and J-type, but it saves a huge amount of space
    read rs1 {{REGISTERS}} arg1
    read rs2 {{REGISTERS}} arg2
    
    # pause if in single-stepping mode, or if we hit the configured breakpoint
    sensor enabled {{SINGLE_STEP_SWITCH}} @enabled
    jump pause_step equal enabled true
    jump pause_step strictEqual pc BREAKPOINT_ADDRESS
done_pause_step:

    # jump to instruction handler
    # TODO: we could save space by using a symbol table, but that would make updating the code a pain
    op add @counter @counter op_id

    jump illegal_instruction always
    jump LUI always
    jump AUIPC always
    jump JAL always
    jump JALR always
    jump BEQ always
    jump BNE always
    jump BLT always
    jump BGE always
    jump BLTU always
    jump BGEU always
    jump LB always
    jump LH always
    jump LW always
    jump LBU always
    jump LHU always
    jump SB always
    jump SH always
    jump SW always
    jump ADDI always
    jump SLTI always
    jump SLTIU always
    jump XORI always
    jump ORI always
    jump ANDI always
    jump SLLI always
    jump SRLI always
    jump SRAI always
    jump ADD always
    jump SLL always
    jump SLT always
    jump SLTU always
    jump XOR always
    jump SRL always
    jump OR always
    jump AND always
    jump SUB always
    jump SRA always
    jump FENCE always
    jump PRIV always
    jump CSRRW always
    jump CSRRS always
    jump CSRRC always
    jump CSRRWI always
    jump CSRRSI always
    jump CSRRCI always
    jump MUL always
    jump MULH always
    jump MULHSU always
    jump MULHU always
    jump DIV always
    jump DIVU always
    jump REM always
    jump REMU always
    jump AMOADD.W always
    jump AMOSWAP.W always
    jump LR.W always
    jump SC.W always
    jump AMOXOR.W always
    jump AMOOR.W always
    jump AMOAND.W always
    jump AMOMIN.W always
    jump AMOMAX.W always
    jump AMOMINU.W always
    jump AMOMAXU.W always
    jump MLOGSYS always
    jump MLOGDRAW always

# we jump here after instruction fetch if the single-step switch is enabled or if we hit an address breakpoint
pause_step:
    control enabled {{PAUSE_SWITCH}} true
    control enabled {{SINGLE_STEP_SWITCH}} true

pause_step__loop:
    sensor enabled {{PAUSE_SWITCH}} @enabled
    jump pause_step__loop equal enabled true

    op add ret @counter 1
    jump reload_config always

    jump done_pause_step always

# most instructions with an output register jump here after completing successfully
# writes result to register arg3 (rd) if rd is not x0
end_instruction_with_result:
    jump end_instruction equal arg3 0
    write result {{REGISTERS}} arg3

# all instructions jump here after completing successfully
end_instruction:
    # increment instret
    op add minstret minstret 1
    jump end_instruction__no_overflow lessThan minstret 0x100000000

    set minstret 0

    op add minstreth minstreth 1
    write minstreth {{CSRS}} "{{ 'minstreth'|csr }}"
    write minstreth {{CSRS}} "{{ 'instreth'|csr }}"

end_instruction__no_overflow:
    write minstret {{CSRS}} "{{ 'minstret'|csr }}"
    write minstret {{CSRS}} "{{ 'instret'|csr }}"

    op add pc pc 4

end_instruction_trap:
    # halt if the reset switch was manually enabled
    sensor enabled {{RESET_SWITCH}} @enabled
    jump main notEqual enabled true

# enable the reset switch, wait until it's disabled, then reset the processor
# this must stay directly after end_instruction
halt:
    control enabled {{RESET_SWITCH}} true
    jump reset always

# exceptions

default_mtvec_handler:
    print "Control transferred to {{DEFAULT_MTVEC}} (default mtvec), halting."
    printflush {{ERROR_OUTPUT}}
    jump halt always

illegal_instruction:
    set mcause 2
    # TODO: return faulting instruction bits?
    # continue into trap_without_mtval

trap_without_mtval:
    set mtval 0
    # continue into trap

trap:
    # set MPIE to MIE, set MIE to 0, and set MPP to privilege_mode
    op and mie mstatus 0b1000
    op shl mpie mie 4

    op shl mpp privilege_mode 11

    op and mstatus mstatus 0b11111111111111111110011101110111
    op or mstatus mstatus mpie
    op or mstatus mstatus mpp
    write mstatus {{CSRS}} "{{ 'mstatus'|csr }}"

    # set mcause
    write mcause {{CSRS}} "{{ 'mcause'|csr }}"

    # set mtval
    write mtval {{CSRS}} "{{ 'mtval'|csr }}"

    # set mepc to pc
    write pc {{CSRS}} "{{ 'mepc'|csr }}"

    # we only support direct mode, so set pc to mtvec
    read pc {{CSRS}} "{{ 'mtvec'|csr }}"

    # we don't have S-mode, so always trap into M-mode
    set privilege_mode 0b11

    jump end_instruction_trap always

# helper functions

# reload config options that are safe to change mid-execution
reload_config:
    # ipt go brrrr
    read TARGET_IPT {{CONFIG}} "TARGET_IPT"
    setrate TARGET_IPT
    set IPT @ipt # for debug output

    read BREAKPOINT_ADDRESS {{CONFIG}} "BREAKPOINT_ADDRESS"

    set @counter ret

# sign extension function
# value, length -> result
extend_sign:
    # https://graphics.stanford.edu/~seander/bithacks.html#VariableSignExtend
    op sub _mask length 1
    op shl _mask 1 _mask

    op xor result value _mask
    op sub result result _mask
    op and result result 0xffffffff # convert signed to unsigned

    set @counter ret

# converts a pair of two's complement unsigned values to signed in-place
# this converts two values at once because most usages of it need to convert two values
# also, the values are assumed to be in rs1 and rs2
# rs1, rs2 -> rs1, rs2
unsigned_to_signed_rs1_rs2:
    # value < 2^31 ? value : value - 2^32
    jump unsigned_to_signed__done_1 lessThan rs1 0x80000000 # 2^31
    op sub rs1 rs1 0x100000000 # 2^32
unsigned_to_signed__done_1:

    jump unsigned_to_signed__done_2 lessThan rs2 0x80000000
    op sub rs2 rs2 0x100000000
unsigned_to_signed__done_2:

    set @counter ret

# get the variable name in CSRS for the specified CSR, and also check if it's read-only
# csr -> variable, readonly
access_csr:
    # the top two bits of csr indicate whether the register is read/write (00, 01, 10) or read-only (11)
    op and readonly csr 0b110000000000
    op equal readonly readonly 0b110000000000

    set _address csr
    set lookup_variable__ret ret
    jump lookup_variable always

# helper function to find the ram proc and variable for a given address
# address -> ram, variable
access_ram:
    op sub _address address {{RAM_START}}

    # we store 4 bytes in each value
    op idiv _address _address 4

access_ram_raw:
    # get the ram proc containing this address
    op idiv _ram_index _address {{RAM_PROC_VARS}}
    op add _ram_index _ram_index RAM_START_PROC

    op mod _ram_x _ram_index MEMORY_WIDTH
    op add _ram_x _ram_x MEMORY_X

    op idiv _ram_y _ram_index MEMORY_WIDTH
    op add _ram_y _ram_y MEMORY_Y

    getblock building ram _ram_x _ram_y

    # get the variable within the ram proc containing this address
    op mod _address _address {{RAM_PROC_VARS}}
    set lookup_variable__ret access_ram__ret

# given a value 0 <= _address < RAM_PROC_VARS, resolve that variable in the lookup table
# this must stay directly after access_ram
# _address -> variable
lookup_variable:
    op idiv _lookup _address {{LOOKUP_PROC_SIZE}}
    op add _lookup _lookup {{LOOKUP_START}}
    getlink _lookup _lookup

    op mod variable _address {{LOOKUP_PROC_SIZE}}
    lookup block variable variable
    sensor variable variable @name
    read variable _lookup variable

    set @counter lookup_variable__ret

# loads the word from memory that contains the specified address
# mcause is required in order to raise the correct exception in case of access fault
# address, mcause, mtval -> result
load_word:
    jump load_rom_word_unchecked lessThan address ROM_SIZE

load_ram_or_mmio_word:
    jump load_mmio_word greaterThanEq address {{MMIO_START}}

    jump trap lessThan address {{RAM_START}}
    jump trap greaterThanEq address RAM_END

load_ram_word_unchecked:
    # locate and read value from ram
    op add access_ram__ret @counter 1
    jump access_ram always
    read value ram variable
    # null is coerced to 0 by swap_endianness

    # tail call, swap_endianness will jump to the ret value of load_word's caller

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# this MUST stay directly after load_word
# value -> result
swap_endianness:
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl _tmp value 8
    op and _tmp _tmp 0xff0000
    op or result result _tmp

    # byte 2 -> byte 1
    op shr _tmp value 8
    op and _tmp _tmp 0xff00
    op or result result _tmp

    # byte 0 -> byte 3
    op shl _tmp value 24
    op and _tmp _tmp 0xff000000
    op or result result _tmp

    set @counter ret

# loads a word from ROM
# address -> result
load_rom_word_unchecked:
    # align to 4 bytes
    op and _address address 0xfffffffc

    # get rom proc data
    op idiv _rom_index _address {{ROM_PROC_BYTES}}

    op mod _rom_x _rom_index MEMORY_WIDTH
    op add _rom_x _rom_x MEMORY_X

    op idiv _rom_y _rom_index MEMORY_WIDTH
    op add _rom_y _rom_y MEMORY_Y

    getblock building _rom _rom_x _rom_y
    read _rom _rom "v"

    # read word and convert to big endian
    set result 0

    op mod _str_index _address {{ROM_PROC_BYTES}}
    set _shift 0 # leftmost byte in memory becomes rightmost byte in word
load_rom_word__loop:
    read _byte _rom _str_index
    op sub _byte _byte {{ROM_BYTE_OFFSET}}
    op max _byte _byte 0 # if we're reading out of bounds, default to 0
    op shl _byte _byte _shift
    op add result result _byte

    op add _str_index _str_index 1
    op add _shift _shift 8
    jump load_rom_word__loop lessThan _shift 32 # stop when we've read 4 bytes

    set _rom null # avoid issues with the vars menu and block data size
    set @counter ret

# address, mcause, mtval -> result
load_mmio_word:
    op sub _jump address {{MMIO_START}}
    op idiv _jump _jump 4
    jump trap greaterThanEq _jump 4

    op mul _jump _jump 2
    op add @counter @counter _jump

    set result mtime; set @counter ret
    set result mtimeh; set @counter ret
    set result mtimecmp; set @counter ret
    set result mtimecmph; set @counter ret

# instruction decoder

# canonical arg order: rs1, rs2, imm, rd
# this allows us to save a lot of space at the expense of a bit of speed by always reading rs1 and rs2 from arg1 and arg2

# R-type: arg1=rs1, arg2=rs2, arg3=rd
# I-type: arg1=rs1, arg2=imm, arg3=rd
# S-type: arg1=rs1, arg2=rs2, arg3=imm
# B-type: arg1=rs1, arg2=rs2, arg3=imm
# U-type: arg1=null, arg2=imm, arg3=rd
# J-type: arg1=null, arg2=imm, arg3=rd

# decoder entry point: decodes a single instruction and writes it to the icache
# the caller MUST set decode_var to null before the first consecutive call to this function
# instruction, decode_address -> op_id, arg1, arg2, arg3
# ret: decode_ret
decode:
    # the lowest 2 bits are always "11" for non-compressed instructions
    # check this first to increase the odds of an early exit for non-code addresses
    op and low_bits instruction 0b11
    jump decode_illegal_instruction notEqual low_bits 0b11

    # opcode
    op and opcode instruction 0b1111111

    # also bail out if we're in the big group of illegal instructions between OP-32 and 48b, or at the end after OP-VE
    jump decode__ok lessThan opcode 0b0111011 # OP-32
    jump decode_illegal_instruction lessThanEq opcode 0b1011111 # 48b
    jump decode_illegal_instruction greaterThanEq opcode 0b1110111 # OP-VE
decode__ok:

    # decode common fields to save space
    # we assume arg1=rs1, arg2=rs2, arg3=rd, which is close enough to most of the formats to save space
    # rs1
    op shr arg1 instruction 15
    op and arg1 arg1 0b11111

    # rs2
    op shr arg2 instruction 20
    op and arg2 arg2 0b11111

    # rd
    op shr arg3 instruction 7
    op and arg3 arg3 0b11111

    # funct3
    op shr funct3 instruction 12
    op and funct3 funct3 0b111

    # many decoders use funct3 * 2 as a counter array jump, so calculate that here to save space
    op mul funct3_x2 funct3 2

    # funct7
    op shr funct7 instruction 25
    op and funct7 funct7 0b1111111

    # counter array based on (opcode >> 2), since the low 2 bits don't matter
    op shr jump opcode 2

    # skip the section of illegal instructions that we already handled above
    jump decode__before_OP-32 lessThan opcode 0b0111011 # OP-32
    op sub jump jump 10
decode__before_OP-32:

    op add @counter @counter jump

    jump decode_LOAD always
    jump decode_illegal_instruction always # LOAD-FP
    jump decode_custom-0 always
    jump decode_MISC-MEM always
    jump decode_OP-IMM always
    jump decode_AUIPC always
    jump decode_illegal_instruction always # OP-IMM-32
    jump decode_illegal_instruction always # 48b
    jump decode_STORE always
    jump decode_illegal_instruction always # STORE-FP
    jump decode_illegal_instruction always # custom-1
    jump decode_AMO always
    jump decode_OP always
    jump decode_LUI always
    # OP-32
    # 64b
    # MADD
    # MSUB
    # NMSUB
    # NMADD
    # OP-FP
    # OP-V
    # custom-2/rv128
    # 48b
    jump decode_BRANCH always
    jump decode_JALR always
    jump decode_illegal_instruction always # reserved
    jump decode_JAL always
    jump decode_SYSTEM always
    # OP-VE
    # custom-3/rv128
    # >=80b

decode_LUI:
    set op_id 1 # LUI
    jump decode_U-type always

decode_AUIPC:
    set op_id 2 # AUIPC
    
decode_U-type:
    # U-type: arg1=null, arg2=imm, arg3=rd
    set arg1 null

    # imm
    op and arg2 instruction 0b11111111111111111111000000000000

    jump end_decode always

decode_JAL:
    # J-type: arg1=null, arg2=imm, arg3=rd
    set arg1 null

    # imm
    op shr imm_20 instruction 11 # instruction[31] -> imm[20]
    op shr imm_11 instruction 9 # instruction[20] -> imm[11]
    op shr imm_10_1 instruction 20 # instruction[30:21] -> imm[10:1]

    op and imm_20 imm_20         0b100000000000000000000
    op and imm_19_12 instruction 0b011111111000000000000 # instruction[19:12] -> imm[19:12]
    op and imm_11 imm_11         0b000000000100000000000
    op and imm_10_1 imm_10_1     0b000000000011111111110

    op add arg2 imm_20 imm_19_12
    op add arg2 arg2 imm_11
    op add arg2 arg2 imm_10_1

    # extend sign
    op xor arg2 arg2 0b100000000000000000000
    op sub arg2 arg2 0b100000000000000000000
    op and arg2 arg2 0xffffffff

    set op_id 3 # JAL
    jump end_decode always

decode_JALR:
    set op_id 4 # JALR
    jump decode_I-type always

decode_BRANCH:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    # imm
    op shr imm_12 instruction 19 # instruction[31] -> imm[12]
    op shl imm_11 instruction 4 # instruction[7] -> imm[11]
    op shr imm_10_5 instruction 20 # instruction[30:25] -> imm[10:5]
    # arg3/rd: instruction[11:8] -> imm[4:1]

    op and imm_12 imm_12     0b1000000000000
    op and imm_11 imm_11     0b0100000000000
    op and imm_10_5 imm_10_5 0b0011111100000
    op and imm_4_1 arg3      0b0000000011110

    op add arg3 imm_12 imm_11
    op add arg3 arg3 imm_10_5
    op add arg3 arg3 imm_4_1

    # extend sign
    op xor arg3 arg3 0b1000000000000
    op sub arg3 arg3 0b1000000000000
    op and arg3 arg3 0xffffffff

    op add @counter @counter funct3_x2

    set op_id 5; jump end_decode always # BEQ
    set op_id 6; jump end_decode always # BNE
    jump decode_illegal_instruction always; stop # this stop should never be executed, it's just to fill space
    jump decode_illegal_instruction always; stop
    set op_id 7; jump end_decode always # BLT
    set op_id 8; jump end_decode always # BGE
    set op_id 9; jump end_decode always # BLTU
    set op_id 10; jump end_decode always # BGEU

decode_LOAD:
    jump decode_illegal_instruction equal funct3 3
    jump decode_illegal_instruction greaterThanEq funct3 6

    # 11: LB
    # 12: LH
    # 13: LW
    # illegal_instruction
    # 14: LBU
    # 15: LHU
    op add op_id 11 funct3
    op greaterThan offset funct3 3 # subtract 1 if funct3 > 3
    op sub op_id op_id offset
    jump decode_I-type always

decode_STORE:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    # imm
    op shl imm_11_5 funct7 5 # instruction[31:25] -> imm[11:5]
    # arg3/rd: instruction[11:7] -> imm[4:0]

    op add arg3 imm_11_5 arg3

    # extend sign
    op xor arg3 arg3 0b100000000000
    op sub arg3 arg3 0b100000000000
    op and arg3 arg3 0xffffffff

    jump decode_illegal_instruction greaterThanEq funct3 3

    op add op_id 16 funct3 # 16 (SB) to 18 (SW)
    jump end_decode always

decode_AMO:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    jump decode_illegal_instruction notEqual funct3 0b010

    # funct5
    # mlogv32 is single-hart, so just ignore aq and rl
    op shr funct5 funct7 2

    # funct5 either has bits in [4:2] or [1:0] set, never both
    # (ab)use that so we don't need 32 lookup table entries
    jump decode_AMO__high greaterThan funct5 0b11

    # low bits
    op add op_id 54 funct5 # 54 (AMOADD.W) to 57 (SC.W)
    jump end_decode always

decode_AMO__high:
    # high bits
    op and low funct5 0b11
    jump decode_illegal_instruction notEqual low 0b00

    # note: funct5 >> 2 starts at 1, not 0
    op shr funct5 funct5 2
    op add op_id 57 funct5 # 58 (AMOXOR.W) to 64 (AMOMAXU.W)
    jump end_decode always

decode_OP-IMM:
    op add @counter @counter funct3_x2

    set op_id 19; jump decode_I-type always # ADDI
    jump decode_SLLI equal funct7 0; jump decode_illegal_instruction always
    set op_id 20; jump decode_I-type always # SLTI
    set op_id 21; jump decode_I-type always # SLTIU
    set op_id 22; jump decode_I-type always # XORI
    jump decode_SRLI_SRAI always; stop
    set op_id 23; jump decode_I-type always # ORI
    set op_id 24; jump decode_I-type always # ANDI

decode_SLLI:
    # shamt is encoded in the low 5 bits of imm, so sign extension is redundant
    set op_id 25 # SLLI
    jump decode_I-type_no_extend_sign always

decode_SRLI_SRAI:
    set op_id 26 # SRLI
    jump decode_I-type_no_extend_sign equal funct7 0b0000000

    # HACK: zero out funct7 so it's not included in imm
    set _funct7 funct7
    set funct7 0
    set op_id 27 # SRAI
    jump decode_I-type_no_extend_sign equal _funct7 0b0100000

    jump decode_illegal_instruction always

decode_OP:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    jump decode_OP_0000000 equal funct7 0b0000000
    jump decode_OP_0100000 equal funct7 0b0100000
    jump decode_OP_0000001 equal funct7 0b0000001
    jump decode_illegal_instruction always

decode_OP_0000000:
    op add op_id 28 funct3 # 28 (ADD) to 35 (AND)
    jump end_decode always

decode_OP_0100000:
    set op_id 36 # SUB
    jump end_decode equal funct3 0b000

    set op_id 37 # SRA
    jump end_decode equal funct3 0b101

    jump decode_illegal_instruction always

# M extension
decode_OP_0000001:
    op add op_id 46 funct3 # 46 (MUL) to 53 (REMU)
    jump end_decode always

decode_MISC-MEM:
    jump decode_illegal_instruction greaterThan funct3 1 # FENCE=0, FENCE.I=1

    set op_id 38 # FENCE/FENCE.I
    jump decode_I-type_no_extend_sign always

decode_SYSTEM:
    jump decode_illegal_instruction equal funct3 4

    # 39: PRIV
    # 40: CSRRW
    # 41: CSRRS
    # 42: CSRRC
    # illegal_instruction
    # 43: CSRRWI
    # 44: CSRRSI
    # 45: CSRRCI
    op add op_id 39 funct3
    op greaterThan offset funct3 4 # subtract 1 if funct3 > 4
    op sub op_id op_id offset
    jump decode_I-type_no_extend_sign always

decode_custom-0:
    # Xmlogsys
    jump decode_illegal_instruction greaterThanEq funct3 2

    op add op_id 65 funct3 # 65 (MLOGSYS) to 66 (MLOGDRAW)
    jump decode_I-type_no_extend_sign always

# common decoder for I-type instructions
# this should be called AFTER setting op_id
decode_I-type:
    set decode_I-type__extend_sign true
decode_I-type_no_extend_sign:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    # imm
    # build this from rs2 and funct7 so that SRAI doesn't need to mutate the instruction
    op shl imm_11_5 funct7 5
    op add arg2 imm_11_5 arg2

    # if we jumped to no_extend_sign, this value will always be null, so skip sign extension
    # otherwise, set it back to null and perform sign extension
    jump end_decode notEqual decode_I-type__extend_sign true
    set decode_I-type__extend_sign null

    # extend sign of imm
    op xor arg2 arg2 0b100000000000
    op sub arg2 arg2 0b100000000000
    op and arg2 arg2 0xffffffff

    jump end_decode always

# must stay directly before end_decode
decode_illegal_instruction:
    # use 0 as the illegal instruction id because null coerces to 0
    set op_id 0

    # set arguments to null to avoid confusion / storing unnecessary data
    # also pass the raw instruction as arg1 to aid in debugging
    # NOTE: we can't use this for the illegal instruction trap handler if raised in PRIV
    set arg1 instruction
    set arg2 null
    set arg3 null

# all decoders jump here after completing successfully
end_decode:
    jump end_decode__no_write_icache strictEqual decode_address null

    # get the current instruction cache processor and variable
    jump end_decode__decode_var_valid notEqual decode_var null
    op add _address ICACHE_START_VAR decode_address
    op add access_ram__ret @counter 1
    jump access_ram_raw always
    set decode_ram ram
    set decode_var variable
end_decode__decode_var_valid:

    # write to the icache
    write op_id decode_ram decode_var
    read decode_var {{INCR}} decode_var
    write arg1 decode_ram decode_var
    read decode_var {{INCR}} decode_var
    write arg2 decode_ram decode_var
    read decode_var {{INCR}} decode_var
    write arg3 decode_ram decode_var
    read decode_var {{INCR}} decode_var

end_decode__no_write_icache:
    set @counter decode_ret

# instruction handlers

LUI:
    # U-type: arg1=null, arg2=imm, arg3=rd
    set result arg2
    jump end_instruction_with_result always

AUIPC:
    # U-type: arg1=null, arg2=imm, arg3=rd
    op add result arg2 pc
    op mod result result 0x100000000 # trunc 32
    jump end_instruction_with_result always

JAL:
    # J-type: arg1=null, arg2=imm, arg3=rd
    op add target pc arg2
    jump unconditional_jump always

JALR:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op add target rs1 arg2
    op and target target 0xfffffffe # clear LSB
    jump unconditional_jump always

BEQ:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch equal rs1 rs2
    jump end_instruction always

BNE:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch notEqual rs1 rs2
    jump end_instruction always

BLT:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always
    # continue into BLTU

BLTU:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch lessThan rs1 rs2
    jump end_instruction always

BGE:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always
    # continue into BGEU

BGEU:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump end_instruction lessThan rs1 rs2
    # continue into conditional_branch if rs1 >= rs2

conditional_branch:
    op add target pc arg3
    set arg3 0 # prevent end_instruction_with_result from writing to a register
    # continue into unconditional_jump

unconditional_jump:
    op mod target target 0x100000000 # trunc 32

    op mod remainder target 4
    set mcause 0 # instruction address misaligned
    set mtval target
    jump trap notEqual remainder 0

    # write pc+4 to rd
    op add result pc 4
    op mod result result 0x100000000 # trunc 32

    # jump to target
    op sub pc target 4 # HACK: end_instruction always increments the pc, so set the new pc to target - 4
    set icache_var null

    jump end_instruction_with_result always

LB:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 8
    set is_signed true

# helper for LOAD instructions to load a value with a specified length in bits (8, 16, or 32) from memory
# raises a misaligned-load exception if the address is misaligned for the specified length
# rs1 (address), arg2 (offset), arg3 (rd), length, is_signed ->
load_value:
    op add address rs1 arg2
    op mod address address 0x100000000 # 2^32 (trunc 32)

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    set mcause 4 # load address misaligned
    set mtval address
    jump trap notEqual _alignment 0

    # load the word containing the address
    set mcause 5 # load access fault
    op add ret @counter 1
    jump load_word always

    # right shift by (address % 4) bits
    op mod _shift address 4
    op mul _shift _shift 8
    op shr result result _shift

    # truncate to the specified number of bits
    op pow _divisor 2 length
    op mod result result _divisor

    # extend the sign of the value if it's signed
    # NOTE: we can't remove the set by changing variable names because we need the final value to be in result in both cases
    set value result
    op add ret @counter 1
    jump extend_sign equal is_signed true

    # write result to rd
    jump end_instruction_with_result always

LH:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 16
    set is_signed true
    jump load_value always

LW:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 32
    set is_signed false
    jump load_value always

LBU:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 8
    set is_signed false
    jump load_value always

LHU:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 16
    set is_signed false
    jump load_value always

SB:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    set length 8

# helper for STORE instructions to store a value with a specified length in bits (8, 16, or 32) to memory
# raises a misaligned-store exception if the address is misaligned for the specified length
# TODO: the 32-bit case could be optimized a lot
# rs1 (address), rs2 (value), arg3 (offset), length ->
store_value:
    op add address rs1 arg3
    op mod address address 0x100000000 # 2^32 (trunc 32)

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    set mcause 6 # store/AMO address misaligned
    set mtval address
    jump trap notEqual _alignment 0

    # create a bitmask with 0 in the section we want to replace and 1 everywhere else
    op mod _shift address 4
    op mul _shift _shift 8

    op pow _length_squared 2 length
    op sub _bitmask _length_squared 1
    op shl _bitmask _bitmask _shift
    op sub _bitmask 0xffffffff _bitmask

    # take the low n bits of the value to store, and shift it to line up with the zeros in the mask
    op mod _value rs2 _length_squared
    op shl _value _value _shift

    # load the word containing the address
    set mcause 7 # store/AMO access fault
    op add ret @counter 1
    jump load_ram_or_mmio_word always

    # insert the value into the word
    op and result result _bitmask
    op add value _value result

    # if it's in the MMIO range, handle it separately
    jump store_mmio_word_unchecked greaterThanEq address {{MMIO_START}}

store_ram_word_unchecked:
    # otherwise, store the new value
    op add ret @counter 1
    jump swap_endianness always

    write result ram variable

    # decode the new value and update the icache to allow executing from RAM and self-modifying code
    # TODO: add a way for the CPU to temporarily disable this for performance?
    set instruction value
    op and decode_address address 0xfffffffc # word-aligned
    set decode_var null

    # only decode if we're in icache range
    op add decode_ret @counter 1
    jump decode lessThan decode_address ICACHE_SIZE

    jump end_instruction always

store_mmio_word_unchecked:
    # trigger a time update
    set next_time_update @time

    # if we get to this point, the MMIO address must be valid, so don't do a bounds check
    op sub _jump address {{MMIO_START}}
    op idiv _jump _jump 4
    op mul _jump _jump 3
    op add @counter @counter _jump

    # mtime
    set mtime value
    set last_time_update @time
    jump end_instruction always
    # mtimeh
    set mtimeh value
    set last_time_update @time
    jump end_instruction always
    # mtimecmp
    set mtimecmp value
    jump end_instruction always
    stop
    # mtimecmph
    set mtimecmph value
    jump end_instruction always

SH:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    set length 16
    jump store_value always

SW:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    set length 32
    jump store_value always

LR.W:
    # R-type: arg1=rs1, arg2=0, arg3=rd

    # check address and alignment
    set mcause 4 # load address misaligned
    op add ret @counter 1
    jump atomic_validate_address always

    # load value
    op add ret @counter 1
    jump load_ram_word_unchecked always

    # register reservation set
    # TODO: implement Za64rs?
    set reservation_set address

    jump end_instruction_with_result always

atomic_validate_address:
    set address rs1
    set mtval address

    op mod alignment address 4
    jump trap notEqual alignment 0

    op add mcause mcause 1 # load/store/AMO access fault
    jump trap lessThan address {{RAM_START}}
    jump trap greaterThanEq address RAM_END

    set @counter ret

SC.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd

    # check address and alignment
    set mcause 6 # store/AMO address misaligned
    op add ret @counter 1
    jump atomic_validate_address always

    # check if reservation is valid and contains rs1
    op strictEqual success address reservation_set

    # invalidate reservation
    set reservation_set null

    # write 0 to rd if successful, else write 1
    jump SC.W__no_write_rd equal arg3 0
    op notEqual result success true
    write result {{REGISTERS}} arg3
SC.W__no_write_rd:

    # conditionally write value
    jump end_instruction notEqual success true

    op add access_ram__ret @counter 1
    jump access_ram always

    set value rs2
    jump store_ram_word_unchecked always

AMOSWAP.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 0 # swap
    
amo:
    # check address and alignment
    set mcause 6 # store/AMO address misaligned
    op add ret @counter 1
    jump atomic_validate_address always

    # read
    op add ret @counter 1
    jump load_ram_word_unchecked always
    
    # put value in rd
    jump amo__no_write_rd equal arg3 0
    write result {{REGISTERS}} arg3
amo__no_write_rd:

    # modify
    set rs1 result # hack
    op add @counter @counter amo_op

    # swap
    set result rs2
    jump amo__done_modify always
    # add
    op add result result rs2
    jump amo__done_modify always
    # and
    op and result result rs2
    jump amo__done_modify always
    # or
    op or result result rs2
    jump amo__done_modify always
    # xor
    op xor result result rs2
    jump amo__done_modify always
    # min
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always
    # continue into minu
    # minu
    op min result rs1 rs2
    jump amo__done_modify always
    # max
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always
    # continue into maxu
    # maxu
    op max result rs1 rs2
amo__done_modify:

    # write
    op and value result 0xffffffff
    jump store_ram_word_unchecked always

AMOADD.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 2 # add
    jump amo always

AMOAND.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 4 # and
    jump amo always

AMOOR.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 6 # or
    jump amo always

AMOXOR.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 8 # xor
    jump amo always

AMOMIN.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 10 # min
    jump amo always

AMOMINU.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 12 # minu
    jump amo always

AMOMAX.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 14 # max
    jump amo always

AMOMAXU.W:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set amo_op 16 # maxu
    jump amo always

# most of the register-register instructions are identical to their register-immediate counterparts
# so just set imm to rs2 and reuse the existing logic, placing them directly before to save space

ADD:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    # continue into ADDI

ADDI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op add result rs1 arg2
    op mod result result 0x100000000 # 2^32 (trunc 32)
    jump end_instruction_with_result always

SLT:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    # continue into SLTI

SLTI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set rs2 arg2
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always

    op lessThan result rs1 rs2

    jump end_instruction_with_result always

SLTU:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    # continue into SLTIU

SLTIU:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op lessThan result rs1 arg2
    jump end_instruction_with_result always

XOR:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    # continue into XORI

XORI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op xor result rs1 arg2
    jump end_instruction_with_result always

OR:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    # continue into ORI

ORI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op or result rs1 arg2
    jump end_instruction_with_result always

AND:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    # continue into ANDI

ANDI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op and result rs1 arg2
    jump end_instruction_with_result always

SLL:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op mod arg2 rs2 32 # 2^5 (trunc 5)
    # continue into SLLI

SLLI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    # truncate before shifting to avoid overflowing 52 integer bits in double
    op sub length 32 arg2
    op pow divisor 2 length

    op mod result rs1 divisor
    op shl result result arg2

    jump end_instruction_with_result always

SRL:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op mod arg2 rs2 32 # 2^5 (trunc 5)
    # continue into SRLI

SRLI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op shr result rs1 arg2
    jump end_instruction_with_result always

SRA:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op mod arg2 rs2 32 # 2^5 (trunc 5)
    # continue into SRAI

SRAI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op shr value rs1 arg2

    op sub length 32 arg2
    op add ret @counter 1
    jump extend_sign always

    jump end_instruction_with_result always

SUB:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    # apply two's complement to negate the value in rs2 and put it into imm
    op sub arg2 0x100000000 rs2
    op mod arg2 arg2 0x100000000
    jump ADDI always

MUL:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op add ret @counter 1
    jump mul_decomp always

    op add result high_low low_high
    op shl result result 16
    op add result result low_low

    op and result result 0xffffffff

    jump end_instruction_with_result always

mul_decomp:
    # https://github.com/es-shims/Math.imul/blob/dab2a3bfc9ce5f4af97057c64ae1880fdbac57a5/implementation.js

    op shr rs1_high rs1 16 # no truncate necessary, rs1 is already 32 bits
    op and rs1_low rs1 0xffff
    op shr rs2_high rs2 16
    op and rs2_low rs2 0xffff

    op mul high_high rs1_high rs2_high
    op mul high_low rs1_high rs2_low
    op mul low_high rs1_low rs2_high
    op mul low_low rs1_low rs2_low

    set @counter ret

MULH:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op greaterThanEq rs1_negative rs1 0x80000000 # check if the sign bit is set
    op greaterThanEq rs2_negative rs2 0x80000000

mulh_s_u:
    op add ret @counter 1
    jump mul_decomp always

    # https://github.com/scala-js/scala-js/blob/7e9dbfcd5c9a9eb3fe065db568c4c96ef4e19a81/linker-private-library/src/main/scala/org/scalajs/linker/runtime/RuntimeLong.scala#L422
    op shr result low_low 16
    op add result result low_high
    op add result result high_low
    op shr result result 16
    op add result result high_high

    # https://stackoverflow.com/a/22847373
    jump mulh_s_u__rs1_positive notEqual rs1_negative true
    op sub result result rs2
mulh_s_u__rs1_positive:

    jump mulh_s_u__rs2_positive notEqual rs2_negative true
    op sub result result rs1
mulh_s_u__rs2_positive:

    op and result result 0xffffffff

    jump end_instruction_with_result always

MULHSU:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op greaterThanEq rs1_negative rs1 0x80000000
    set rs2_negative false
    jump mulh_s_u always

MULHU:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set rs1_negative false
    set rs2_negative false
    jump mulh_s_u always

DIV:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always
    # continue into DIVU

DIVU:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    jump div_by_zero equal rs2 0

    # use div instead of idiv and then cast to long so that it rounds towards zero
    # https://stackoverflow.com/a/8387377
    op div result rs1 rs2
    op and result result 0xffffffff

    jump end_instruction_with_result always

div_by_zero:
    # all bits set
    set result 0xffffffff
    jump end_instruction_with_result always

REM:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op add ret @counter 1
    jump unsigned_to_signed_rs1_rs2 always
    # continue into REMU

# reimu?
REMU:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    jump rem_by_zero equal rs2 0

    op mod result rs1 rs2
    op and result result 0xffffffff # only necessary for signed

    jump end_instruction_with_result always

rem_by_zero:
    # dividend
    set result rs1
    jump end_instruction_with_result always

FENCE:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    # note: this currently also handles FENCE.I, but that will need to change if we want either of them to not be a no-op

    # PAUSE
    # TODO: there's probably a better way to do this
    jump FENCE__not_pause notEqual arg1 0
    jump FENCE__not_pause notEqual arg2 0b000000010000
    jump FENCE__not_pause notEqual arg3 0

    wait 0.00001

FENCE__not_pause:
    # no-op
    jump end_instruction always

PRIV:
    # I-type: arg1=rs1/uimm, arg2=funct12/csr, arg3=rd
    # we partially decode this at runtime to simplify the decoding logic
    # privilege mode changes should be relatively rare, so it should be fine for them to be a bit slower
    jump ECALL equal arg2 0
    jump EBREAK equal arg2 1
    jump MRET equal arg2 0b001100000010
    jump end_instruction equal arg2 0b000100000101 # WFI (no-op, ignore TW bit)
    jump illegal_instruction always

ECALL:
    # 0b1000 (8) = ecall from U-mode
    # 0b1011 (11) = ecall from S-mode
    op or mcause 0b1000 privilege_mode
    jump trap_without_mtval always

EBREAK:
    set mcause 3 # breakpoint
    # mtval is set to pc by main
    jump trap always

MRET:
    jump illegal_instruction lessThan privilege_mode 0b11

    # set MIE to MPIE, set MPIE to 1, set privilege_mode to MPP, and set MPP to U
    op and mpie mstatus 0b10000000
    op shr mie mpie 4

    op and privilege_mode mstatus 0b1100000000000
    op shr privilege_mode privilege_mode 11

    op and mstatus mstatus 0b11111111111111111110011111110111
    op or mstatus mstatus mie
    op or mstatus mstatus 0b10000000 # MPIE
    write mstatus {{CSRS}} "{{ 'mstatus'|csr }}"

    # set pc to MEPC
    read pc {{CSRS}} "{{ 'mepc'|csr }}"
    op sub pc pc 4

    # check for interrupts
    set next_time_update @time

    jump end_instruction always

CSRRWI:
    # CSRI-type: arg1=uimm, arg2=csr, arg3=rd
    set rs1 arg1
    # continue into CSRRW

CSRRW:
    # CSR-type: arg1=rs1, arg2=csr, arg3=rd
    set csr_op 0 # read/write
    jump read_modify_write_csr always

CSRRSI:
    # CSRI-type: arg1=uimm, arg2=csr, arg3=rd
    set rs1 arg1
    # continue into CSRRS

CSRRS:
    # CSR-type: arg1=rs1, arg2=csr, arg3=rd
    set csr_op 2 # read and set bits
    jump read_modify_write_csr always

CSRRCI:
    # CSRI-type: arg1=uimm, arg2=csr, arg3=rd
    set rs1 arg1
    # continue into CSRRC

CSRRC:
    # CSR-type: arg1=rs1, arg2=csr, arg3=rd
    set csr_op 4 # read and clear bits
    # continue into read_modify_write_csr

read_modify_write_csr:
    set csr arg2
    op add ret @counter 1
    jump access_csr always

    # read

    read result {{CSRS}} variable

    # modify

    op add @counter @counter csr_op

    # read/write (always write)
    set new_value rs1
    jump read_modify_write_csr__always_write always
    # read and set bits (conditional write)
    op or new_value rs1 result
    jump read_modify_write_csr__conditional_write always
    # read and clear bits (conditional write)
    op not new_value rs1
    op and new_value new_value result

    # write

read_modify_write_csr__conditional_write:
    jump end_instruction_with_result equal arg1 0

read_modify_write_csr__always_write:
    jump illegal_instruction equal readonly true

    # handlers for specific CSRs
    jump end_instruction_with_result equal variable "{{ 'misa'|csr }}" # read-only
    jump read_modify_write_csr__mstatus equal variable "{{ 'mstatus'|csr }}"
    jump read_modify_write_csr__mip equal variable "{{ 'mip'|csr }}"
    jump read_modify_write_csr__mie equal variable "{{ 'mie'|csr }}"
    jump read_modify_write_csr__mepc equal variable "{{ 'mepc'|csr }}"
    jump read_modify_write_csr__mtvec equal variable "{{ 'mtvec'|csr }}"
    jump read_modify_write_csr__mcycle equal variable "{{ 'mcycle'|csr }}"
    jump read_modify_write_csr__mcycleh equal variable "{{ 'mcycleh'|csr }}"
    jump read_modify_write_csr__minstret equal variable "{{ 'minstret'|csr }}"
    jump read_modify_write_csr__minstreth equal variable "{{ 'minstreth'|csr }}"
read_modify_write_csr__end_handler:

    write new_value {{CSRS}} variable
    jump end_instruction_with_result always

read_modify_write_csr__mstatus:
    # clear WPRI and read-only zero fields
    # SD/XS/FS/VS                -              ----  --
    # WPRI                        --------                  - - -
    # S-mode                              - ---         -  -   -
    # UBE                                                 -
    op and mstatus new_value 0b00000000001000100001100010001000

    # if MPP was set to 10 (reserved) or 01 (S), set it to 0
    op and mpp mstatus 0b1100000000000
    jump read_modify_write_csr__mstatus__mpp_m equal mpp 0b1100000000000
    op and mstatus mstatus 0b11111111111111111110011111111111
read_modify_write_csr__mstatus__mpp_m:

    # check for interrupts
    set next_time_update @time

    jump read_modify_write_csr__end_handler always

read_modify_write_csr__mip:
    # clear read-only fields
    # 0                                          -- - - - - - - -
    # LCOFIP                                       -
    # read-only                                      -   -
    # S-mode                                           -   -   -
    # MSIP                                                   -
    op and new_value new_value 0b11111111111111110000100010000000

    # enforce read-only non-zero fields
    # MEIP                                  -
    # MTIP                                      -
    op and tmp result 0b00000000000000000000100010000000
    op or new_value new_value tmp

    # check for interrupts
    set next_time_update @time

    jump read_modify_write_csr__end_handler always

read_modify_write_csr__mie:
    # clear read-only zero fields
    # 0                                          -- - - - - - - -
    # LCOFIE                                       -
    # S-mode                                           -   -   -
    # MSIE                                                   -
    op and new_value new_value 0b11111111111111110000100010000000

    # check for interrupts
    set next_time_update @time

    jump read_modify_write_csr__end_handler always

read_modify_write_csr__mepc:
    # IALIGN=32, so the two low bits of mepc are always zero
    op and new_value new_value 0xfffffffc
    jump read_modify_write_csr__end_handler always

read_modify_write_csr__mtvec:
    # only allow direct mode
    op and new_value new_value 0xfffffffc
    jump read_modify_write_csr__end_handler always

read_modify_write_csr__mcycle:
    set mcycle new_value
    set last_cycle_update @tick
    set next_time_update @time
    jump end_instruction_with_result always

read_modify_write_csr__mcycleh:
    set mcycleh new_value
    set next_time_update @time
    jump end_instruction_with_result always

read_modify_write_csr__minstret:
    # a value written to instret by one instruction should be the value read by the following instruction
    op sub minstret new_value 1
    jump end_instruction_with_result always

read_modify_write_csr__minstreth:
    # if minstret is going to overflow on this increment, minstreth should be new_value - 1 so that it has the expected value for the next instruction
    op equal is_minstret_overflowing minstret 0xffffffff
    op sub minstreth new_value is_minstret_overflowing

    # we need to write this in case minstreth doesn't update this tick
    write minstreth {{CSRS}} "{{ 'minstreth'|csr }}"
    write minstreth {{CSRS}} "{{ 'instreth'|csr }}"
    
    jump end_instruction_with_result always

MLOGSYS:
    # I-type: arg1=rs1, arg2=funct12, arg3=rd
    jump illegal_instruction greaterThan arg2 5
    
    op mul jump arg2 2
    op add @counter @counter jump

    # halt
    jump halt always
    stop # placeholder

    # printchar
    printchar rs1
    jump end_instruction always

    # printflush
    printflush {{ERROR_OUTPUT}}
    jump end_instruction always

    # drawflush
    drawflush {{DISPLAY}}
    jump end_instruction always

    # read sortKB
    jump MLOGSYS__read_sortKB always
    stop

    # initialize icache
    # NOTE: if we add more instructions to MLOGSYS, this needs to move to its own label

    op min __etext rs1 ROM_SIZE
    op min __etext __etext ICACHE_SIZE

    # decode .text
    set STATE "decoding"
    set decode_address 0
    set decode_var null

MLOGSYS__init_icache__loop:
    set address decode_address
    op add ret @counter 1
    jump load_rom_word_unchecked always
    set instruction result

    op add decode_ret @counter 1
    jump decode always

    op add decode_address decode_address 4
    jump MLOGSYS__init_icache__loop lessThan decode_address __etext

    set STATE "running"
    jump end_instruction always

MLOGSYS__read_sortKB:
    # check the current ptr and return 0 if we've already reached it
    # NOTE: this will fail if the user has typed 63 characters since we last checked
    set result 0
    read ptr {{KBCONV_DATA}} 63
    jump end_instruction_with_result equal kbconv_rptr ptr

    # read the char at the current ptr
    read result {{KBCONV_DATA}} kbconv_rptr

    # increment rptr
    op add kbconv_rptr kbconv_rptr 1
    op mod kbconv_rptr kbconv_rptr 63

    jump end_instruction_with_result always

MLOGDRAW:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump illegal_instruction greaterThan arg2 15

    read a0 {{REGISTERS}} 10
    read a1 {{REGISTERS}} 11
    read a2 {{REGISTERS}} 12
    read a3 {{REGISTERS}} 13
    read a4 {{REGISTERS}} 14
    read a5 {{REGISTERS}} 15

    op mul jump arg2 2
    op add @counter @counter jump

    # draw_clear
    draw clear a0 a1 a2
    jump end_instruction always

    # draw_color
    draw color a0 a1 a2 a3
    jump end_instruction always

    # draw_col
    jump MLOGDRAW_draw_col always
    stop

    # draw_stroke
    draw stroke a0
    jump end_instruction always

    # draw_line
    draw line a0 a1 a2 a3
    jump end_instruction always

    # draw_rect
    draw rect a0 a1 a2 a3
    jump end_instruction always

    # draw_lineRect
    draw lineRect a0 a1 a2 a3
    jump end_instruction always

    # draw_poly
    draw poly a0 a1 a2 a3 a4
    jump end_instruction always

    # draw_linePoly
    draw linePoly a0 a1 a2 a3 a4
    jump end_instruction always

    # draw_triangle
    draw triangle a0 a1 a2 a3 a4 a5
    jump end_instruction always

    # draw_image
    jump MLOGDRAW_draw_image always
    stop

    # draw_print
    jump MLOGDRAW_draw_print always
    stop

    # draw_translate
    draw translate a0 a1
    jump end_instruction always

    # draw_scale
    draw scale a0 a1
    jump end_instruction always

    # draw_rotate
    draw rotate a0
    jump end_instruction always

    # draw_reset
    draw reset
    jump end_instruction always

MLOGDRAW_draw_col:
    op mul a0 a0 %00000001
    draw col a0
    jump end_instruction always

MLOGDRAW_draw_image:
    jump illegal_instruction greaterThanEq a2 4

    op mul a2 a2 2 # instructions per index
    op add @counter @counter a2

    lookup block image a3; jump MLOGDRAW_draw_image__end always
    lookup unit image a3; jump MLOGDRAW_draw_image__end always
    lookup item image a3; jump MLOGDRAW_draw_image__end always
    lookup liquid image a3; jump MLOGDRAW_draw_image__end always

MLOGDRAW_draw_image__end:
    jump MLOGDRAW_draw_image__lookup_fail strictEqual image null

    set result 1
    draw image a0 a1 image a4 a5
    jump end_instruction_with_result always

MLOGDRAW_draw_image__lookup_fail:
    set result 0
    jump end_instruction_with_result always

MLOGDRAW_draw_print:
    jump illegal_instruction greaterThanEq a2 9

    op mul a2 a2 2 # instructions per index
    op add @counter @counter a2

    draw print a0 a1 bottom; jump end_instruction always
    draw print a0 a1 bottomLeft; jump end_instruction always
    draw print a0 a1 bottomRight; jump end_instruction always
    draw print a0 a1 center; jump end_instruction always
    draw print a0 a1 left; jump end_instruction always
    draw print a0 a1 right; jump end_instruction always
    draw print a0 a1 top; jump end_instruction always
    draw print a0 a1 topLeft; jump end_instruction always
    draw print a0 a1 topRight; jump end_instruction always

#% endblock contents

# disable mlogls warnings
# put this at the end of the file so it's not included in the output
# and so that if we go over the 1000 instruction limit, we can ignore the errors below this line
# {% raw %}
# preprocessor variable definitions
set {{ null
set {{LOOKUP_START}} null
set {{REGISTERS}} null
set {{CSRS}} null
set {{INCR}} null
set {{CONFIG}} null
set {{ERROR_OUTPUT}} null
set {{RESET_SWITCH}} null
set {{PAUSE_SWITCH}} null
set {{SINGLE_STEP_SWITCH}} null
set {{KBCONV_DATA}} null
set {{DISPLAY}} null
set {{LOOKUP_PROC_SIZE}} null
set {{ROM_BYTE_OFFSET}} null
set {{ROM_PROC_BYTES}} null
set {{RAM_PROC_VARS}} null
set {{RAM_START}} null
set {{MMIO_START}} null
set {{DEFAULT_MTVEC}} null
# unused variables
set {{ {{
set STATE STATE
set IPT IPT
# {% endraw %}
