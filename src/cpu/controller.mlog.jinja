#% from 'worker.mlog.jinja' import fetch_variables

#% extends 'constants.jinja'
#% block contents

#% set REGISTERS = 'cell1'
#% set LABELS = 'cell2'

#% set CSRS = 'processor17'
#% set INCR = 'processor18'
#% set CONFIG = 'processor19'

#% set ERROR_OUTPUT = 'message1'

#% set POWER_SWITCH = 'switch1'
#% set PAUSE_SWITCH = 'switch2'
#% set SINGLE_STEP_SWITCH = 'switch3'

    # we ONLY reset this variable if the controller is rebuilt or manually restarted
    set skip_slow_init false

# disable the power switch, then reset
halt:
    control enabled {{POWER_SWITCH}} false
    control enabled {{PAUSE_SWITCH}} false

# wait until the power switch is enabled, then reset/start
reset:
    setrate 1000

    # tell workers to halt
    set prev_proc @this
    set state "halt"

    # load config
    read MEMORY_X {{CONFIG}} "MEMORY_X"
    read MEMORY_Y {{CONFIG}} "MEMORY_Y"
    read MEMORY_WIDTH {{CONFIG}} "MEMORY_WIDTH"
    read ROM_SIZE {{CONFIG}} "ROM_SIZE"
    read RAM_SIZE {{CONFIG}} "RAM_SIZE"
    read ICACHE_SIZE {{CONFIG}} "ICACHE_SIZE"
    read UART_FIFO_MODULO {{CONFIG}} "UART_FIFO_MODULO"

    op idiv RAM_START_PROC ROM_SIZE {{ROM_PROC_BYTES}}

    op add RAM_END {{RAM_START}} RAM_SIZE

    op add END_PROC RAM_SIZE ICACHE_SIZE
    op idiv END_PROC END_PROC {{RAM_PROC_BYTES}}
    op add END_PROC END_PROC RAM_START_PROC

    # loop until the power switch is linked and enabled
    sensor enabled {{POWER_SWITCH}} @enabled
    jump reset equal enabled false

    # initialize CPU

    # align to tick
    wait 1e-5

    # change state from halt to reset, and set prev_proc again in case a worker changed it
    set prev_proc @this
    set state "reset"

    jump end_slow_init equal skip_slow_init true

    # disable RAM procs

    set i 0
disable_ram:
    op mod x i MEMORY_WIDTH
    op add x x MEMORY_X

    op idiv y i MEMORY_WIDTH
    op add y y MEMORY_Y

    getblock building ram x y

    op lessThan enabled i RAM_START_PROC
    control enabled ram enabled

    op add i i 1
    jump disable_ram lessThan i END_PROC

    # initialize INCR

    set address 0
    op add ret @counter 1
    jump lookup_variable always
    set prev_variable variable

    set address 1
init_incr:
    set variable null
    op add ret @counter 1
    jump lookup_variable lessThan address {{RAM_PROC_VARS}}

    write variable {{INCR}} prev_variable
    set prev_variable variable
    op add address address 1
    jump init_incr lessThanEq address {{RAM_PROC_VARS}}

    # initialize label lookup table

#% for instruction in instructions
    # {{ instruction.label }}
    write {{labels[instruction.label]}} {{LABELS}} {{loop.index0}}
#% endfor

    # ^ all of this only needs to run once, so skip it on subsequent runs to make startup faster
    set skip_slow_init true
end_slow_init:

    # initialize peripherals

    # text output
    printflush {{ERROR_OUTPUT}}

    # icache
    set __etext 0

    # reset hart state as per machine-level ISA

    # set privilege mode to M
    set privilege_mode 0b11

    # clear mstatus
    # technically we're only supposed to clear MPRV and MIE, but the other bits are explicitly unspecified, so this is allowed
    set csr_mstatus 0
    
    # set pc to reset vector
    set pc 0
    set icache_var null

    # set mcause to 0, since we don't distinguish different reset conditions
    # use null so the debugger can tell if it's a reset or a misaligned instruction
    write null {{CSRS}} "{{ 'mcause'|csr }}"
    
    # clear LR/SC reservation set
    set reservation_set null

    # reset additional (unspecified) hart state

    # clear timers
    set csr_mtime 0
    set csr_mtimeh 0
    set csr_mtimecmp 0
    set csr_mtimecmph 0
    set csr_minstret 0
    set csr_minstreth 0
    write 0 {{CSRS}} "{{ 'mcycle'|csr }}"
    write 0 {{CSRS}} "{{ 'mcycleh'|csr }}"

    # clear pending/enabled interrupts
    set csr_mip 0
    set csr_mie 0
    set interrupt_flags 0b00

    # reset mtvec to implementation-defined value to help catch bugs
    write {{SYSCON}} {{CSRS}} "{{ 'mtvec'|csr }}"

    # misa
    # XLEN=32 --
    # 0         ----
    # ISA           ZYXWVUTSRQPONMLKJIHGFEDCBA
    write   0b01000000100100000001000100000001 {{CSRS}} "{{ 'misa'|csr }}"

    # mlogv32 only has one hart, so mhartid is required to be zero
    write 0 {{CSRS}} "{{ 'mhartid'|csr }}"

    # read-only zero CSRs
    write 0 {{CSRS}} "{{ 'mvendorid'|csr }}"
    write 0 {{CSRS}} "{{ 'marchid'|csr }}"
    write 0 {{CSRS}} "{{ 'mimpid'|csr }}"

    # default values for writable CSRs
    write 0 {{CSRS}} "{{ 'mepc'|csr }}"
    write 0 {{CSRS}} "{{ 'mscratch'|csr }}"
    write 0 {{CSRS}} "{{ 'mtval'|csr }}"

    # clear critical section if set
    set controller_critical_section null

    # align to tick
    wait 1e-5

    # set mtime/mcycle reference points
    set last_mtime_update @time
    set last_mcycle_update @tick

    # start the workers
    set prev_proc @this
    set state "running"

next_tick:
    wait 1e-5

    # fetch current hart state
    # note: we DO NOT update prev_proc here if not halting

    #{{ '\n' }}{{ fetch_variables() }}

    # perform any state transitions requested by the workers
    # if halting/resetting, we don't modify the requesting worker's @counter
    jump halt equal state "halt"
    jump reset equal state "reset"
    jump pause equal state "pause"
end_pause:

    # poll hardware
    sensor enabled {{POWER_SWITCH}} @enabled
    jump state->halt equal enabled false

    # check which CSR we're currently updating, if any

    # update time
    # TODO: handle mtimeh/mcycleh overflow

    jump skip_mtime_update equal controller_critical_section "mtime"

    op sub delta_ms @time last_mtime_update

    op add csr_mtime csr_mtime delta_ms
    op floor csr_mtime csr_mtime

    op shr overflow csr_mtime 32
    op add csr_mtimeh csr_mtimeh overflow

    op mod csr_mtime csr_mtime 0x100000000

    write csr_mtime prev_proc "csr_mtime"
    write csr_mtimeh prev_proc "csr_mtimeh"

skip_mtime_update:
    set last_mtime_update @time

    # update cycle
    # we define the rate of increase of cycle as "@ipt * ticks"
    # this should be a decent estimation of the number of mlog instructions executed

    jump skip_mcycle_update equal controller_critical_section "mcycle"

    read csr_mcycle {{CSRS}} "{{ 'mcycle'|csr }}"
    read csr_mcycleh {{CSRS}} "{{ 'mcycleh'|csr }}"

    op sub delta_cycles @tick last_mcycle_update
    op mul delta_cycles delta_cycles @ipt

    op add csr_mcycle csr_mcycle delta_cycles
    op floor csr_mcycle csr_mcycle

    op shr overflow csr_mcycle 32
    op add csr_mcycleh csr_mcycleh overflow

    op mod csr_mcycle csr_mcycle 0x100000000

    write csr_mcycle {{CSRS}} "{{ 'mcycle'|csr }}"
    write csr_mcycleh {{CSRS}} "{{ 'mcycleh'|csr }}"
    write csr_mcycle {{CSRS}} "{{ 'cycle'|csr }}"
    write csr_mcycleh {{CSRS}} "{{ 'cycleh'|csr }}"

skip_mcycle_update:
    set last_mcycle_update @tick

    # tell the next worker to poll and fire interrupts
    write 0b11 prev_proc "interrupt_flags"

    # go to next tick

    jump next_tick always

state->halt:
    write 0 prev_proc "@counter"
    jump halt always

pause:
    control enabled {{SINGLE_STEP_SWITCH}} true
    control enabled {{PAUSE_SWITCH}} true

pause__loop:
    wait 1e-5

    sensor enabled {{POWER_SWITCH}} @enabled
    jump state->halt equal enabled false

    sensor enabled {{PAUSE_SWITCH}} @enabled
    jump pause__loop equal enabled true

    read counter prev_proc "@counter"
    op add counter counter 1
    write counter prev_proc "@counter"

    set state "running"
    write state prev_proc "state"

    jump end_pause always

# given a value 0 <= address < RAM_PROC_SIZE, resolve that variable in the lookup table
# address -> variable
lookup_variable:
    op idiv _lookup address {{LOOKUP_PROC_SIZE}}
    getlink _lookup _lookup

    op mod variable address {{LOOKUP_PROC_SIZE}}
    lookup block variable variable
    sensor variable variable @name
    read variable _lookup variable

    set @counter ret

#% endblock contents

# disable mlogls warnings
# {% raw %}
# common preprocessor constants
set {{LOOKUP_PROC_SIZE}} null
set {{ROM_PROC_BYTES}} null
set {{RAM_PROC_BYTES}} null
set {{RAM_PROC_VARS}} null
set {{RAM_START}} null
set {{SYSCON}} null
# local preprocessor constants
set {{LABELS}} null
set {{CSRS}} null
set {{INCR}} null
set {{CONFIG}} null
set {{ERROR_OUTPUT}} null
set {{SINGLE_STEP_SWITCH}} null
set {{POWER_SWITCH}} null
set {{PAUSE_SWITCH}} null
set {{labels[instruction.label]}} null
set {{loop.index0}} null
# unused variables
set _ UART_FIFO_MODULO
set _ RAM_END
set _ pc
set _ icache_var
set _ __etext
set _ privilege_mode
set _ reservation_set
set _ csr_mtime
set _ csr_mtimeh
set _ csr_mtimecmp
set _ csr_mtimecmph
set _ csr_mcycle
set _ csr_mcycleh
set _ csr_minstret
set _ csr_minstreth
set _ csr_mstatus
set _ csr_mip
set _ csr_mie
set _ interrupt_flags
# {% endraw %}
