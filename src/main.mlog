    # constants
    set LOOKUP_PROC_SIZE 260  # number of variables per lookup proc
    set MEMORY_PROC_SIZE 4096  # number of variables (not bytes) per memory proc
    
reset:
    set STATE "reset" # for debug output

    # linked buildings
    set REGISTERS cell1
    set CSRS processor17
    set INCR processor18
    set CONFIG processor19

    set ERROR_OUTPUT message1
    set RESET_SWITCH switch1
    set PAUSE_SWITCH switch2
    set SINGLE_STEP_SWITCH switch3

    set DISPLAY display1

    # load config
    read IPT CONFIG "IPT"
    read MEMORY_X_OFFSET CONFIG "MEMORY_X_OFFSET"
    read MEMORY_Y_OFFSET CONFIG "MEMORY_Y_OFFSET"
    read MEMORY_WIDTH CONFIG "MEMORY_WIDTH"
    read ROM_SIZE CONFIG "ROM_SIZE"
    read RAM_SIZE CONFIG "RAM_SIZE"

    op add MEMORY_X MEMORY_X_OFFSET @thisx
    op add MEMORY_Y MEMORY_Y_OFFSET @thisy

    set ROM_START 0x0  # inclusive
    op add ROM_END ROM_START ROM_SIZE  # exclusive

    set RAM_START ROM_END  # inclusive
    op add RAM_END RAM_START RAM_SIZE  # exclusive

    set MEMORY_END RAM_END
    op idiv MEMORY_END_INDEX MEMORY_END 4

    # loop until the reset switch is linked and disabled
    jump reset strictEqual RESET_SWITCH null
    sensor enabled RESET_SWITCH @enabled
    jump reset equal enabled true

    # initialization

    # ipt go brrrr
    setrate IPT

    # initialize peripherals
    control enabled PAUSE_SWITCH false

    printflush ERROR_OUTPUT

    draw clear 0 0 0
    drawflush DISPLAY

    # find the index of the first linked lookup proc
    # NOTE: the lookup procs must be linked in a contiguous group
    # eg. if you link lookup procs, then a switch, then want to add more lookup procs, you need to replace the proc and re-link everything
    # also, things may fail if the lookups haven't been given enough time to initialize, so do that first
    set i -1
reset__find_lookup_start:
    op add i i 1
    getlink block i
    sensor type block @type
    jump reset__find_lookup_start notEqual type @micro-processor
    read type_var block "_type"
    jump reset__find_lookup_start notEqual type_var "lookup"

    set LOOKUP_START i

    # look up commonly used CSRs
    set csr 0xc00
    op add ret @counter 1
    jump access_csr always
    set CSR_CYCLE variable
    
    set csr 0xc01
    op add ret @counter 1
    jump access_csr always
    set CSR_TIME variable

    set csr 0xc02
    op add ret @counter 1
    jump access_csr always
    set CSR_INSTRET variable

    set csr 0xc80
    op add ret @counter 1
    jump access_csr always
    set CSR_CYCLEH variable
    
    set csr 0xc81
    op add ret @counter 1
    jump access_csr always
    set CSR_TIMEH variable

    set csr 0xc82
    op add ret @counter 1
    jump access_csr always
    set CSR_INSTRETH variable

    # read __etext from address 0, or default to ROM_SIZE if __etext is 0
    set address 0
    op add ret @counter 1
    jump load_word always
    set __etext result

    jump reset__nonzero_etext notEqual __etext 0
    set __etext ROM_SIZE
reset__nonzero_etext:

    # decode .text
    set STATE "decoding"
    set decode_start_time @time
    set decode_duration null # for debug output
    set decode_address 4
    set decode_var null

reset__decode:
    set address decode_address
    op add ret @counter 1
    jump load_word always
    set instruction result

    op add decode_ret @counter 1
    jump decode always

    op add decode_address decode_address 4
    jump reset__decode lessThan decode_address __etext

    op sub decode_duration @time decode_start_time
    set STATE "running"

    # start executing code at address 4 (address 0 is __etext)
    set pc 4
    set icache_var null

    # reset instret
    write 0 CSRS CSR_INSTRET
    write 0 CSRS CSR_INSTRETH
    set instret 0

    # start cycle timer
    set next_time_update @time
    set RESET_TIME @time
    set RESET_TICK @tick

main:
    # update time/cycle
    jump main__skip_time_update lessThan @time next_time_update
    op add next_time_update @time 1
    op add ret @counter 1
    jump update_time_and_cycle always
main__skip_time_update:

    # get the current instruction cache processor and variable
    jump access_icache strictEqual icache_var null
done_access_icache:

    # load instruction and arguments
    read op_id icache_ram icache_var
    read icache_var INCR icache_var
    read arg1 icache_ram icache_var
    read icache_var INCR icache_var
    read arg2 icache_ram icache_var
    read icache_var INCR icache_var
    read arg3 icache_ram icache_var
    read icache_var INCR icache_var

    # read rs1 and rs2
    # this wastes 1 cycle for I-type and 2 cycles for U-type and J-type, but it saves a huge amount of space
    read rs1 REGISTERS arg1
    read rs2 REGISTERS arg2
    
    # pause if in single-stepping mode
    sensor enabled SINGLE_STEP_SWITCH @enabled
    jump pause_step equal enabled true
done_pause_step:

    # jump to instruction handler
    # TODO: we could save space by using a symbol table, but that would make updating the code a pain
    op add @counter @counter op_id

    jump illegal_instruction always
    jump LUI always
    jump AUIPC always
    jump JAL always
    jump JALR always
    jump BEQ always
    jump BNE always
    jump BLT always
    jump BGE always
    jump BLTU always
    jump BGEU always
    jump LB always
    jump LH always
    jump LW always
    jump LBU always
    jump LHU always
    jump SB always
    jump SH always
    jump SW always
    jump ADDI always
    jump SLTI always
    jump SLTIU always
    jump XORI always
    jump ORI always
    jump ANDI always
    jump SLLI always
    jump SRLI always
    jump SRAI always
    jump ADD always
    jump SUB always
    jump SLL always
    jump SLT always
    jump SLTU always
    jump XOR always
    jump SRL always
    jump SRA always
    jump OR always
    jump AND always
    jump FENCE always
    jump PRIV always
    jump CSRRW always
    jump CSRRS always
    jump CSRRC always
    jump CSRRWI always
    jump CSRRSI always
    jump CSRRCI always

# we jump here at the start of the main loop if icache_var is null
access_icache:
    jump inaccessible_load greaterThanEq pc ROM_SIZE

    op add _address MEMORY_END_INDEX pc
    op add access_ram__ret @counter 1
    jump access_ram_raw always

    set icache_ram ram
    set icache_var variable

    jump done_access_icache always

# we jump here after instruction fetch if the single-step switch is enabled
pause_step:
    op add ret @counter 1
    jump update_time_and_cycle always

    control enabled PAUSE_SWITCH true
    set pause_step_tick @tick

pause_step__loop:
    sensor enabled RESET_SWITCH @enabled
    jump halt equal reset_enabled true
    sensor enabled PAUSE_SWITCH @enabled
    jump pause_step__loop equal enabled true

    # move RESET_TICK forward by the amount of time we were paused for
    # this should have the effect of pausing cycle while paused here
    op sub delta @tick pause_step_tick
    op add RESET_TICK RESET_TICK delta

    op add ret @counter 1
    jump update_time_and_cycle always

    jump done_pause_step always

# all instructions jump here after completing successfully
end_instruction:
    # increment instret
    op add instret instret 1
    jump end_instruction__no_overflow lessThan instret 0x100000000

    set instret 0

    read high CSRS CSR_INSTRETH
    op add high high 1
    write high CSRS CSR_INSTRETH

end_instruction__no_overflow:
    write instret CSRS CSR_INSTRET

end_instruction_preserve_instret:
    op add pc pc 4

    # halt if the reset switch was manually enabled
    sensor enabled RESET_SWITCH @enabled
    jump main notEqual enabled true

# enable the reset switch, wait until it's disabled, then reset the processor
# this must stay directly after end_instruction
halt:
    op add ret @counter 1
    jump update_time_and_cycle always

    control enabled RESET_SWITCH true
    jump reset always

# exceptions

illegal_instruction:
    print "Illegal instruction!"
    printflush ERROR_OUTPUT
    jump halt always

illegal_syscall:
    print "Illegal syscall!"
    printflush ERROR_OUTPUT
    jump halt always

instruction_address_misaligned:
    print "Instruction address misaligned!"
    printflush ERROR_OUTPUT
    jump halt always

misaligned_load:
    print "Attempted misaligned load!"
    printflush ERROR_OUTPUT
    jump halt always

misaligned_store:
    print "Attempted misaligned store!"
    printflush ERROR_OUTPUT
    jump halt always

inaccessible_load:
    print "Attempted to load from an inaccessible address!"
    printflush ERROR_OUTPUT
    jump halt always

inaccessible_store:
    print "Attempted to store to an inaccessible address!"
    printflush ERROR_OUTPUT
    jump halt always

# helper functions

# update the time/timeh and cycle/cycleh CSRs
# TODO: we could theoretically only update these when they're actually being read, but that would look weird on a debugger
update_time_and_cycle:
    # update time
    op sub time @time RESET_TIME
    op floor time time

    op mod low time 0x100000000
    op shr high time 32

    write low CSRS CSR_TIME
    write high CSRS CSR_TIMEH

    # update cycle
    # we define the number of cycles as "@ipt * ticks since reset"
    # this should be a decent estimation of the number of mlog instructions executed since reset
    op sub cycle @tick RESET_TICK
    op mul cycle cycle @ipt
    op floor cycle cycle

    op mod low cycle 0x100000000
    op shr high cycle 32

    write low CSRS CSR_CYCLE
    write high CSRS CSR_CYCLEH

    set @counter ret

# sign extension function
# value, length -> result
extend_sign:
    # https://graphics.stanford.edu/~seander/bithacks.html#VariableSignExtend
    op sub _mask length 1
    op shl _mask 1 _mask

    op xor result value _mask
    op sub result result _mask
    op and result result 0xffffffff # convert signed to unsigned

    set @counter ret

# converts a pair of two's complement unsigned values to signed, or vice versa
# this converts two values at once because every usage of it needs to convert two values
# also, the values are assumed to be in rs1 and rs2
# rs1, rs2 -> result1, result2
swap_signedness:
    # rs1 < 2^31 ? (rs1 + 2^32) % 2^32 : rs1 - 2^32
    jump swap_signedness__s2u_1 lessThan rs1 0x80000000 # 2^31
    op sub result1 rs1 0x100000000 # 2^32
    jump swap_signedness__done_1 always
swap_signedness__s2u_1:
    op add result1 rs1 0x100000000
    op mod result1 result1 0x100000000
swap_signedness__done_1:

    jump swap_signedness__s2u_2 lessThan rs2 0x80000000
    op sub result2 rs2 0x100000000
    jump swap_signedness__done_2 always
swap_signedness__s2u_2:
    op add result2 rs2 0x100000000
    op mod result2 result2 0x100000000
swap_signedness__done_2:

    set @counter ret

# get the variable name in CSRS for the specified CSR, and also check if it's read-only
# csr -> variable, readonly
access_csr:
    # the top two bits of csr indicate whether the register is read/write (00, 01, 10) or read-only (11)
    op and readonly csr 0b110000000000
    op equal readonly readonly 0b110000000000

    set _address csr
    set lookup_variable__ret ret
    jump lookup_variable always

# helper function to find the ram proc and variable for a given address
# address -> ram, variable
access_ram:
    # we store 4 bytes in each value
    op idiv _address address 4

access_ram_raw:
    # get the ram proc containing this address
    op idiv _ram_index _address MEMORY_PROC_SIZE

    op mod _ram_x _ram_index MEMORY_WIDTH
    op add _ram_x _ram_x MEMORY_X

    op idiv _ram_y _ram_index MEMORY_WIDTH
    op add _ram_y _ram_y MEMORY_Y

    getblock building ram _ram_x _ram_y

    # get the variable within the ram proc containing this address
    op mod _address _address MEMORY_PROC_SIZE
    set lookup_variable__ret access_ram__ret

# given a value 0 <= _address < MEMORY_PROC_SIZE, resolve that variable in the lookup table
# this must stay directly after access_ram
# _address -> variable
lookup_variable:
    op idiv _lookup _address LOOKUP_PROC_SIZE
    op add _lookup _lookup LOOKUP_START
    getlink _lookup _lookup

    op mod variable _address LOOKUP_PROC_SIZE
    lookup block variable variable
    sensor variable variable @name
    read variable _lookup variable

    set @counter lookup_variable__ret

# loads the word from memory that contains the specified address
# address -> result
load_word:
    jump inaccessible_load greaterThanEq address MEMORY_END

    # locate and read value from ram
    op add access_ram__ret @counter 1
    jump access_ram always
    read value ram variable
    # null is coerced to 0 by swap_endianness

    # tail call, swap_endianness will jump to the ret value of load_word's caller

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# this MUST stay directly after load_word
# value -> result
swap_endianness:
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl _tmp value 8
    op and _tmp _tmp 0xff0000
    op or result result _tmp

    # byte 2 -> byte 1
    op shr _tmp value 8
    op and _tmp _tmp 0xff00
    op or result result _tmp

    # byte 0 -> byte 3
    op shl _tmp value 24
    op and _tmp _tmp 0xff000000
    op or result result _tmp

    set @counter ret

# instruction decoder

# canonical arg order: rs1, rs2, imm, rd
# this allows us to save a lot of space at the expense of a bit of speed by always reading rs1 and rs2 from arg1 and arg2

# R-type: arg1=rs1, arg2=rs2, arg3=rd
# I-type: arg1=rs1, arg2=imm, arg3=rd
# S-type: arg1=rs1, arg2=rs2, arg3=imm
# B-type: arg1=rs1, arg2=rs2, arg3=imm
# U-type: arg1=null, arg2=imm, arg3=rd
# J-type: arg1=null, arg2=imm, arg3=rd

# decoder entry point: decodes a single instruction and writes it to the icache
# the caller MUST set decode_var to null before the first consecutive call to this function
# instruction, decode_address -> op_id, arg1, arg2, arg3
# ret: decode_ret
decode:
    # decode common fields to save space
    # we assume arg1=rs1, arg2=rs2, arg3=rd, which is close enough to most of the formats to save space
    # rs1
    op shr arg1 instruction 15
    op and arg1 arg1 0b11111

    # rs2
    op shr arg2 instruction 20
    op and arg2 arg2 0b11111

    # rd
    op shr arg3 instruction 7
    op and arg3 arg3 0b11111

    # funct3
    op shr funct3 instruction 12
    op and funct3 funct3 0b111

    # many decoders use funct3 * 2 as a counter array jump, so calculate that here to save space
    op mul funct3_x2 funct3 2

    # funct7
    op shr funct7 instruction 25
    op and funct7 funct7 0b1111111

    # the lowest 2 bits are always "11" for non-compressed instructions
    op and low_bits instruction 0b11
    jump decode_illegal_instruction notEqual low_bits 0b11

    # counter array based on (opcode >> 2), since the low 2 bits don't matter
    op and opcode instruction 0b1111111
    op shr jump opcode 2
    op add @counter @counter jump

    jump decode_LOAD always
    jump decode_illegal_instruction always # LOAD-FP
    jump decode_illegal_instruction always # custom-0
    jump decode_MISC-MEM always
    jump decode_OP-IMM always
    jump decode_AUIPC always
    jump decode_illegal_instruction always # OP-IMM-32
    jump decode_illegal_instruction always # 48b
    jump decode_STORE always
    jump decode_illegal_instruction always # STORE-FP
    jump decode_illegal_instruction always # custom-1
    jump decode_illegal_instruction always # AMO
    jump decode_OP always
    jump decode_LUI always
    jump decode_illegal_instruction always # OP-32
    jump decode_illegal_instruction always # 64b
    jump decode_illegal_instruction always # MADD
    jump decode_illegal_instruction always # MSUB
    jump decode_illegal_instruction always # NMSUB
    jump decode_illegal_instruction always # NMADD
    jump decode_illegal_instruction always # OP-FP
    jump decode_illegal_instruction always # OP-V
    jump decode_illegal_instruction always # custom-2/rv128
    jump decode_illegal_instruction always # 48b
    jump decode_BRANCH always
    jump decode_JALR always
    jump decode_illegal_instruction always # reserved
    jump decode_JAL always
    jump decode_SYSTEM always
    jump decode_illegal_instruction always # OP-VE
    jump decode_illegal_instruction always # custom-3/rv128
    jump decode_illegal_instruction always # >=80b

decode_LUI:
    set op_id 1 # LUI
    jump decode_U-type always

decode_AUIPC:
    set op_id 2 # AUIPC
    
decode_U-type:
    # U-type: arg1=null, arg2=imm, arg3=rd
    set arg1 null

    # imm
    op and arg2 instruction 0b11111111111111111111000000000000

    jump end_decode always

decode_JAL:
    # J-type: arg1=null, arg2=imm, arg3=rd
    set arg1 null

    # imm
    op shr imm_20 instruction 11 # instruction[31] -> imm[20]
    op shr imm_11 instruction 9 # instruction[20] -> imm[11]
    op shr imm_10_1 instruction 20 # instruction[30:21] -> imm[10:1]

    op and imm_20 imm_20         0b100000000000000000000
    op and imm_19_12 instruction 0b011111111000000000000 # instruction[19:12] -> imm[19:12]
    op and imm_11 imm_11         0b000000000100000000000
    op and imm_10_1 imm_10_1     0b000000000011111111110

    op add arg2 imm_20 imm_19_12
    op add arg2 arg2 imm_11
    op add arg2 arg2 imm_10_1

    # extend sign
    op xor arg2 arg2 0b100000000000000000000
    op sub arg2 arg2 0b100000000000000000000
    op and arg2 arg2 0xffffffff

    set op_id 3 # JAL
    jump end_decode always

decode_JALR:
    set op_id 4 # JALR
    jump decode_I-type always

decode_BRANCH:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    # imm
    op shr imm_12 instruction 19 # instruction[31] -> imm[12]
    op shl imm_11 instruction 4 # instruction[7] -> imm[11]
    op shr imm_10_5 instruction 20 # instruction[30:25] -> imm[10:5]
    # arg3/rd: instruction[11:8] -> imm[4:1]

    op and imm_12 imm_12     0b1000000000000
    op and imm_11 imm_11     0b0100000000000
    op and imm_10_5 imm_10_5 0b0011111100000
    op and imm_4_1 arg3      0b0000000011110

    op add arg3 imm_12 imm_11
    op add arg3 arg3 imm_10_5
    op add arg3 arg3 imm_4_1

    # extend sign
    op xor arg3 arg3 0b1000000000000
    op sub arg3 arg3 0b1000000000000
    op and arg3 arg3 0xffffffff

    op add @counter @counter funct3_x2

    set op_id 5; jump end_decode always # BEQ
    set op_id 6; jump end_decode always # BNE
    jump decode_illegal_instruction always; stop # this stop should never be executed, it's just to fill space
    jump decode_illegal_instruction always; stop
    set op_id 7; jump end_decode always # BLT
    set op_id 8; jump end_decode always # BGE
    set op_id 9; jump end_decode always # BLTU
    set op_id 10; jump end_decode always # BGEU

decode_LOAD:
    jump decode_illegal_instruction greaterThanEq funct3 6

    op add @counter @counter funct3_x2

    set op_id 11; jump decode_I-type always # LB
    set op_id 12; jump decode_I-type always # LH
    set op_id 13; jump decode_I-type always # LW
    jump decode_illegal_instruction always; stop
    set op_id 14; jump decode_I-type always # LBU
    set op_id 15; jump decode_I-type always # LHU

decode_STORE:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    # imm
    op shl imm_11_5 funct7 5 # instruction[31:25] -> imm[11:5]
    # arg3/rd: instruction[11:7] -> imm[4:0]

    op add arg3 imm_11_5 arg3

    # extend sign
    op xor arg3 arg3 0b100000000000
    op sub arg3 arg3 0b100000000000
    op and arg3 arg3 0xffffffff

    jump decode_illegal_instruction greaterThanEq funct3 3

    op add @counter @counter funct3_x2

    set op_id 16; jump end_decode always # SB
    set op_id 17; jump end_decode always # SH
    set op_id 18; jump end_decode always # SW

decode_OP-IMM:
    op add @counter @counter funct3_x2

    set op_id 19; jump decode_I-type always # ADDI
    jump decode_SLLI equal funct7 0; jump decode_illegal_instruction always
    set op_id 20; jump decode_I-type always # SLTI
    set op_id 21; jump decode_I-type always # SLTIU
    set op_id 22; jump decode_I-type always # XORI
    jump decode_SRLI_SRAI always; stop
    set op_id 23; jump decode_I-type always # ORI
    set op_id 24; jump decode_I-type always # ANDI

decode_SLLI:
    # shamt is encoded in the low 5 bits of imm, so sign extension is redundant
    set op_id 25 # SLLI
    jump decode_I-type_no_extend_sign always

decode_SRLI_SRAI:
    set op_id 26 # SRLI
    jump decode_I-type_no_extend_sign equal funct7 0b0000000

    # HACK: zero out funct7 so it's not included in imm
    set _funct7 funct7
    set funct7 0
    set op_id 27 # SRAI
    jump decode_I-type_no_extend_sign equal _funct7 0b0100000

    jump decode_illegal_instruction always

decode_OP:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    jump decode_OP_0000000 equal funct7 0b0000000
    jump decode_OP_0100000 equal funct7 0b0100000
    jump decode_illegal_instruction always

decode_OP_0000000:
    op add @counter @counter funct3_x2

    set op_id 28; jump end_decode always # ADD
    set op_id 30; jump end_decode always # SLL
    set op_id 31; jump end_decode always # SLT
    set op_id 32; jump end_decode always # SLTU
    set op_id 33; jump end_decode always # XOR
    set op_id 34; jump end_decode always # SRL
    set op_id 36; jump end_decode always # OR
    set op_id 37; jump end_decode always # AND

decode_OP_0100000:
    set op_id 29 # SUB
    jump end_decode equal funct3 0b000

    set op_id 35 # SRA
    jump end_decode equal funct3 0b101

    jump decode_illegal_instruction always

decode_MISC-MEM:
    jump decode_illegal_instruction notEqual funct3 0

    set op_id 38 # FENCE
    jump decode_I-type_no_extend_sign always

decode_SYSTEM:
    op add @counter @counter funct3_x2

    set op_id 39; jump decode_I-type_no_extend_sign always # PRIV
    set op_id 40; jump decode_I-type_no_extend_sign always # CSRRW
    set op_id 41; jump decode_I-type_no_extend_sign always # CSRRS
    set op_id 42; jump decode_I-type_no_extend_sign always # CSRRC
    jump decode_illegal_instruction always; stop
    set op_id 43; jump decode_I-type_no_extend_sign always # CSRRWI
    set op_id 44; jump decode_I-type_no_extend_sign always # CSRRSI
    set op_id 45; jump decode_I-type_no_extend_sign always # CSRRCI

# common decoder for I-type instructions
# this should be called AFTER setting op_id
decode_I-type:
    set decode_I-type__extend_sign true
decode_I-type_no_extend_sign:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    # imm
    # build this from rs2 and funct7 so that SRAI doesn't need to mutate the instruction
    op shl imm_11_5 funct7 5
    op add arg2 imm_11_5 arg2

    # if we jumped to no_extend_sign, this value will always be null, so skip sign extension
    # otherwise, set it back to null and perform sign extension
    jump end_decode notEqual decode_I-type__extend_sign true
    set decode_I-type__extend_sign null

    # extend sign of imm
    op xor arg2 arg2 0b100000000000
    op sub arg2 arg2 0b100000000000
    op and arg2 arg2 0xffffffff

    jump end_decode always

# must stay directly before end_decode
decode_illegal_instruction:
    # use 0 as the illegal instruction id because null coerces to 0
    set op_id 0

    # set arguments to null to avoid confusion / storing unnecessary data
    # also pass the raw instruction as arg1 to aid in debugging
    # NOTE: we can't use this for the illegal instruction trap handler if raised in PRIV
    set arg1 instruction
    set arg2 null
    set arg3 null

# all decoders jump here after completing successfully
end_decode:
    jump end_decode__no_write_icache strictEqual decode_address null

    # get the current instruction cache processor and variable
    jump end_decode__decode_var_valid notEqual decode_var null
    op add _address MEMORY_END_INDEX decode_address
    op add access_ram__ret @counter 1
    jump access_ram_raw always
    set decode_ram ram
    set decode_var variable
end_decode__decode_var_valid:

    # write to the icache
    write op_id decode_ram decode_var
    read decode_var INCR decode_var
    write arg1 decode_ram decode_var
    read decode_var INCR decode_var
    write arg2 decode_ram decode_var
    read decode_var INCR decode_var
    write arg3 decode_ram decode_var
    read decode_var INCR decode_var

end_decode__no_write_icache:
    set @counter decode_ret

# instruction handlers

LUI:
    # U-type: arg1=null, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0
    write arg2 REGISTERS arg3
    jump end_instruction always

AUIPC:
    # U-type: arg1=null, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op add result arg2 pc
    op mod result result 0x100000000 # trunc 32
    write result REGISTERS arg3

    jump end_instruction always

JAL:
    # J-type: arg1=null, arg2=imm, arg3=rd
    op add target pc arg2

unconditional_jump:
    op mod target target 0x100000000 # trunc 32

    op mod remainder target 4
    jump instruction_address_misaligned notEqual remainder 0

    jump unconditional_jump__no_write equal arg3 0

    op add result pc 4
    op mod result result 0x100000000 # trunc 32
    write result REGISTERS arg3

unconditional_jump__no_write:
    op sub pc target 4 # HACK: end_instruction always increments the pc, so set the new pc to target - 4
    set icache_var null
    jump end_instruction always

JALR:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    op add target rs1 arg2
    jump unconditional_jump always

BEQ:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch equal rs1 rs2
    jump end_instruction always

conditional_branch:
    op add target pc arg3
    op mod target target 0x100000000 # trunc 32

    op mod remainder target 4
    jump instruction_address_misaligned notEqual remainder 0

    op sub pc target 4 # HACK: end_instruction always increments the pc, so set the new pc to target - 4
    set icache_var null
    jump end_instruction always

BNE:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch notEqual rs1 rs2
    jump end_instruction always

BLT:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    op add ret @counter 1
    jump swap_signedness always

    jump conditional_branch lessThan result1 result2
    jump end_instruction always

BGE:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    op add ret @counter 1
    jump swap_signedness always

    jump conditional_branch greaterThanEq result1 result2
    jump end_instruction always

BLTU:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch lessThan rs1 rs2
    jump end_instruction always

BGEU:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    jump conditional_branch greaterThanEq rs1 rs2
    jump end_instruction always

LB:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 8
    set is_signed true

# helper for LOAD instructions to load a value with a specified length in bits (8, 16, or 32) from memory
# raises a misaligned-load exception if the address is misaligned for the specified length
# rs1 (address), arg2 (offset), arg3 (rd), length, is_signed ->
load_value:
    op add address rs1 arg2
    op mod address address 0x100000000 # 2^32 (trunc 32)

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    jump misaligned_load notEqual _alignment 0

    # load the word containing the address
    op add ret @counter 1
    jump load_word always

    # now that we know we don't need to throw an exception, bail out if rd is x0
    jump end_instruction equal arg3 0

    # right shift by (address % 4) bits
    op mod _shift address 4
    op mul _shift _shift 8
    op shr result result _shift

    # truncate to the specified number of bits
    op pow _divisor 2 length
    op mod result result _divisor

    # extend the sign of the value if it's signed
    # NOTE: we can't remove the set by changing variable names because we need the final value to be in result in both cases
    set value result
    op add ret @counter 1
    jump extend_sign equal is_signed true

    # write value to rd
    write result REGISTERS arg3
    jump end_instruction always

LH:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 16
    set is_signed true
    jump load_value always

LW:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 32
    set is_signed false
    jump load_value always

LBU:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 8
    set is_signed false
    jump load_value always

LHU:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    set length 16
    set is_signed false
    jump load_value always

SB:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    set length 8

# helper for STORE instructions to store a value with a specified length in bits (8, 16, or 32) to memory
# raises a misaligned-store exception if the address is misaligned for the specified length
# rs1 (address), rs2 (value), arg3 (offset), length ->
store_value:
    op add address rs1 arg3
    op mod address address 0x100000000 # 2^32 (trunc 32)
    jump inaccessible_store lessThan address RAM_START
    jump inaccessible_store greaterThanEq address RAM_END

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    jump misaligned_store notEqual _alignment 0

    # take the low n bits of the value to store, and shift it to line up with the zeros in the mask (big endian)
    op mod _shift address 4
    op mul _shift _shift 8

    op pow _length_squared 2 length
    op mod value rs2 _length_squared
    op shl value value _shift

    # convert the value to little endian
    op add ret @counter 1
    jump swap_endianness always

    # create a bitmask with 0 in the section we want to replace and 1 everywhere else (little endian)
    op sub _shift 24 _shift
    op idiv _shift _shift length
    op mul _shift _shift length

    op sub _bitmask _length_squared 1
    op shl _bitmask _bitmask _shift
    op sub _bitmask 0xffffffff _bitmask

    # load the word containing the address
    op add access_ram__ret @counter 1
    jump access_ram always
    read _word ram variable

    # insert the value into the word
    op and _word _word _bitmask
    op add result result _word

    # store the new value
    write result ram variable

    jump end_instruction always

SH:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    set length 16
    jump store_value always

SW:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    set length 32
    jump store_value always

ADDI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op add result rs1 arg2
    op mod result result 0x100000000 # 2^32 (trunc 32)

    write result REGISTERS arg3
    jump end_instruction always

SLTI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    set rs2 arg2
    op add ret @counter 1
    jump swap_signedness always

    op lessThan result result1 result2

    write result REGISTERS arg3
    jump end_instruction always

SLTIU:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op lessThan result rs1 arg2

    write result REGISTERS arg3
    jump end_instruction always

XORI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op xor result rs1 arg2

    write result REGISTERS arg3
    jump end_instruction always

ORI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op or result rs1 arg2

    write result REGISTERS arg3
    jump end_instruction always

ANDI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op and result rs1 arg2

    write result REGISTERS arg3
    jump end_instruction always

SLLI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    # truncate before shifting to avoid overflowing 52 integer bits in double
    op sub length 32 arg2
    op pow divisor 2 length

    op mod result rs1 divisor
    op shl result result arg2

    write result REGISTERS arg3
    jump end_instruction always

SRLI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op shr result rs1 arg2

    write result REGISTERS arg3
    jump end_instruction always

SRAI:
    # I-type: arg1=rs1, arg2=imm, arg3=rd
    jump end_instruction equal arg3 0

    op shr value rs1 arg2

    op sub length 32 arg2
    op add ret @counter 1
    jump extend_sign always

    write result REGISTERS arg3
    jump end_instruction always

# most of the register-register instructions are identical to their register-immediate counterparts
# so just set imm to rs2 and reuse the existing logic

ADD:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    jump ADDI always

SUB:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    # apply two's complement to negate the value in rs2 and put it into imm
    op sub arg2 0x100000000 rs2
    op mod arg2 arg2 0x100000000

    jump ADDI always

SLL:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op mod arg2 rs2 32 # 2^5 (trunc 5)
    jump SLLI always

SLT:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    jump SLTI always

SLTU:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    jump SLTIU always

XOR:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    jump XORI always

SRL:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op mod arg2 rs2 32 # 2^5 (trunc 5)
    jump SRLI always

SRA:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    op mod arg2 rs2 32 # 2^5 (trunc 5)
    jump SRAI always

OR:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    jump ORI always

AND:
    # R-type: arg1=rs1, arg2=rs2, arg3=rd
    set arg2 rs2
    jump ANDI always

FENCE:
    # I-type: arg1=rs1, arg2=imm, arg3=rd

    # PAUSE
    # TODO: there's probably a better way to do this
    jump FENCE__not_pause notEqual arg1 0
    jump FENCE__not_pause notEqual arg2 0b000000010000
    jump FENCE__not_pause notEqual arg3 0

    wait 0.00001

FENCE__not_pause:
    # no-op
    jump end_instruction always

PRIV:
    # I-type: arg1=rs1/uimm, arg2=funct12/csr, arg3=rd
    # we partially decode this at runtime to simplify the decoding logic
    # privilege mode changes should be relatively rare, so it should be fine for them to be a bit slower
    jump ECALL equal arg2 0
    jump EBREAK equal arg2 1
    jump illegal_instruction always

ECALL:
    # TODO: this code should be moved to a custom instruction and/or MMIO
    # ECALL has a different meaning in the privileged spec, this is not what it's supposed to be for
    # see: https://jborza.com/post/2021-04-21-ecalls-and-syscalls/

    read a0 REGISTERS 10
    read a1 REGISTERS 11
    read a2 REGISTERS 12
    read a3 REGISTERS 13
    read a4 REGISTERS 14
    read a5 REGISTERS 15
    read a7 REGISTERS 17

    jump illegal_syscall lessThan a7 0 # this SHOULD never happen, but just in case
    jump illegal_syscall greaterThanEq a7 20 # number of syscalls

    op mul jump a7 2
    op add @counter @counter jump

    # halt
    jump halt always
    stop # to fill space

    # printchar
    printchar a0
    jump end_instruction_preserve_instret always

    # printflush
    printflush ERROR_OUTPUT
    jump end_instruction_preserve_instret always

    # draw_clear
    draw clear a0 a1 a2
    jump end_instruction_preserve_instret always

    # draw_color
    draw color a0 a1 a2 a3
    jump end_instruction_preserve_instret always

    # draw_col
    jump ECALL_draw_col always
    stop

    # draw_stroke
    draw stroke a0
    jump end_instruction_preserve_instret always

    # draw_line
    draw line a0 a1 a2 a3
    jump end_instruction_preserve_instret always

    # draw_rect
    draw rect a0 a1 a2 a3
    jump end_instruction_preserve_instret always

    # draw_lineRect
    draw lineRect a0 a1 a2 a3
    jump end_instruction_preserve_instret always

    # draw_poly
    draw poly a0 a1 a2 a3 a4
    jump end_instruction_preserve_instret always

    # draw_linePoly
    draw linePoly a0 a1 a2 a3 a4
    jump end_instruction_preserve_instret always

    # draw_triangle
    draw triangle a0 a1 a2 a3 a4 a5
    jump end_instruction_preserve_instret always

    # draw_image
    jump ECALL_draw_image always
    stop

    # draw_print
    jump ECALL_draw_print always
    stop

    # draw_translate
    draw translate a0 a1
    jump end_instruction_preserve_instret always

    # draw_scale
    draw scale a0 a1
    jump end_instruction_preserve_instret always

    # draw_rotate
    draw rotate a0
    jump end_instruction_preserve_instret always

    # draw_reset
    draw reset
    jump end_instruction_preserve_instret always

    # drawflush
    drawflush DISPLAY
    jump end_instruction_preserve_instret always

ECALL_draw_col:
    op mul a0 a0 %00000001
    draw col a0
    jump end_instruction_preserve_instret always

ECALL_draw_image:
    op mod a2 a2 4 # number of indices
    op mul a2 a2 2 # instructions per index
    op add @counter @counter a2

    lookup block image a3; jump ECALL_draw_image__end always
    lookup unit image a3; jump ECALL_draw_image__end always
    lookup item image a3; jump ECALL_draw_image__end always
    lookup liquid image a3; jump ECALL_draw_image__end always

ECALL_draw_image__end:
    jump ECALL_draw_image__lookup_fail strictEqual image null

    write 1 REGISTERS 10
    draw image a0 a1 image a4 a5
    jump end_instruction_preserve_instret always

ECALL_draw_image__lookup_fail:
    write 0 REGISTERS 10
    jump end_instruction_preserve_instret always

ECALL_draw_print:
    op mod a2 a2 9 # number of indices
    op mul a2 a2 2 # instructions per index
    op add @counter @counter a2

    draw print a0 a1 bottom; jump end_instruction_preserve_instret always
    draw print a0 a1 bottomLeft; jump end_instruction_preserve_instret always
    draw print a0 a1 bottomRight; jump end_instruction_preserve_instret always
    draw print a0 a1 center; jump end_instruction_preserve_instret always
    draw print a0 a1 left; jump end_instruction_preserve_instret always
    draw print a0 a1 right; jump end_instruction_preserve_instret always
    draw print a0 a1 top; jump end_instruction_preserve_instret always
    draw print a0 a1 topLeft; jump end_instruction_preserve_instret always
    draw print a0 a1 topRight; jump end_instruction_preserve_instret always

EBREAK:
    op add ret @counter 1
    jump update_time_and_cycle always

    control enabled PAUSE_SWITCH true
    print "Paused on EBREAK, disable pause switch to continue"
    printflush ERROR_OUTPUT

    set pause_tick @tick

EBREAK__loop:
    sensor reset_enabled RESET_SWITCH @enabled
    jump halt equal reset_enabled true
    sensor pause_enabled PAUSE_SWITCH @enabled
    jump EBREAK__loop equal pause_enabled true

    # move RESET_TICK forward by the amount of time we were paused for
    # this should have the effect of pausing cycle while paused here
    op sub delta @tick pause_tick
    op add RESET_TICK RESET_TICK delta

    op add ret @counter 1
    jump update_time_and_cycle always

    printflush ERROR_OUTPUT
    jump end_instruction_preserve_instret always

CSRRW:
    # CSR-type: arg1=rs1, arg2=csr, arg3=rd
    set csr_op 0 # read/write
    jump read_modify_write_csr always

CSRRS:
    # CSR-type: arg1=rs1, arg2=csr, arg3=rd
    set csr_op 2 # read and set bits
    jump read_modify_write_csr always

CSRRC:
    # CSR-type: arg1=rs1, arg2=csr, arg3=rd
    set csr_op 4 # read and clear bits
    jump read_modify_write_csr always

CSRRWI:
    # CSRI-type: arg1=uimm, arg2=csr, arg3=rd
    set rs1 arg1
    set csr_op 0 # read/write
    jump read_modify_write_csr always

CSRRSI:
    # CSRI-type: arg1=uimm, arg2=csr, arg3=rd
    set rs1 arg1
    set csr_op 2 # read and set bits
    jump read_modify_write_csr always

CSRRCI:
    # CSRI-type: arg1=uimm, arg2=csr, arg3=rd
    set rs1 arg1
    set csr_op 4 # read and clear bits

read_modify_write_csr:
    set csr arg2
    op add ret @counter 1
    jump access_csr always

    # read

    read value CSRS variable

    # modify

    op add @counter @counter csr_op

    # read/write (always write)
    set result value
    jump read_modify_write_csr__always_write always
    # read and set bits (conditional write)
    op or result rs1 value
    jump read_modify_write_csr__conditional_write always
    # read and clear bits (conditional write)
    op not result rs1
    op and result result value

    # write

read_modify_write_csr__conditional_write:
    jump read_modify_write_csr__skip_write equal arg1 0
read_modify_write_csr__always_write:
    jump illegal_instruction equal readonly true

    write result CSRS variable

    # write initial CSR value to rd

read_modify_write_csr__skip_write:
    jump end_instruction equal arg3 0
    write value REGISTERS arg3
    jump end_instruction always
