reset:
    # constants
    set ERROR_OUTPUT message1
    set RESET_SWITCH switch1
    set PAUSE_SWITCH switch2
    set REGISTERS cell1
    set MEMORY bank1 # TODO: support multiple memory banks

    # initialization

    printflush ERROR_OUTPUT

    control enabled RESET_SWITCH false
    control enabled PAUSE_SWITCH false

    set i 0
reset__zero_registers:
    write 0 REGISTERS i
    op add i i 1
    jump reset__zero_registers lessThan i 32

    set pc 0
    
main:
    # load instruction
    set address pc
    op add ret @counter 1
    jump load_word always
    set instruction result

    # decode instruction

    op mod opcode instruction 128 # 2^7 (trunc 7)

    # instructions disambiguated by just the opcode

    jump LUI equal opcode 55
    jump AUIPC equal opcode 23
    jump JAL equal opcode 111

    # all below instructions use rs1, so just decode and read it here
    # note: rs1_id is stored as a separate variable because FENCE needs it
    op shr rs1_id instruction 15
    op mod rs1_id rs1_id 32 # 2^5 (trunc 5)
    read rs1 REGISTERS rs1_id

    jump JALR equal opcode 103

    # instructions disambiguated by funct3

    op shr funct3 instruction 12
    op mod funct3 funct3 8 # 2^3 (trunc 3)
    
    jump decode_branch equal opcode 99
    jump decode_load equal opcode 3
    jump decode_save equal opcode 35
    jump decode_system equal opcode 115
    jump FENCE equal opcode 15

    # instructions disambiguated by funct7

    op shr funct7 instruction 25
    op mod funct7 funct7 128 # 2^7 (trunc 7)

    jump decode_arithmetic_imm equal opcode 19
    jump decode_arithmetic equal opcode 51

    # :(
    jump illegal_instruction always

decode_branch:
    # B-type
    # imm
    op shr imm_11 instruction 7
    op mod imm_11 imm_11 2 # 2^1 (trunc 1)
    op shl imm_11 imm_11 11

    op shr imm_4_1 instruction 8
    op mod imm_4_1 imm_4_1 16 # 2^4 (trunc 4)
    op shl imm_4_1 imm_4_1 1

    op shr imm_10_5 instruction 25
    op mod imm_10_5 imm_10_5 64 # 2^6 (trunc 6)
    op shl imm_10_5 imm_10_5 5

    op shr imm_12 instruction 31
    op mod imm_12 imm_12 2 # 2^1 (trunc 1)
    op shl imm_12 imm_12 12

    op add imm imm_4_1 imm_10_5
    op add imm imm imm_11
    op add imm imm imm_12

    set value imm
    set length 13
    op add ret @counter 1
    jump extend_sign always
    set imm result

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    jump BEQ equal funct3 0
    jump BNE equal funct3 1
    jump BLT equal funct3 4
    jump BGE equal funct3 5
    jump BLTU equal funct3 6
    jump BGEU equal funct3 7
    jump illegal_instruction always

decode_load:
    # I-type
    op add ret @counter 1
    jump decode_type_I always

    jump LB equal funct3 0
    jump LH equal funct3 1
    jump LW equal funct3 2
    jump LBU equal funct3 4
    jump LHU equal funct3 5
    jump illegal_instruction always

decode_save:
    # S-type
    # imm
    op shr imm_4_0 instruction 7
    op mod imm_4_0 imm_4_0 32 # 2^5 (trunc 5)

    op shr imm_11_5 instruction 25
    op mod imm_11_5 imm_11_5 128 # 2^7 (trunc 7)
    op shl imm_11_5 imm_11_5 5

    op add imm imm_4_0 imm_11_5

    set value imm
    set length 12
    op add ret @counter 1
    jump extend_sign always
    set imm result

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    jump SB equal funct3 0
    jump SH equal funct3 1
    jump SW equal funct3 2
    jump illegal_instruction always

decode_system:
    jump illegal_instruction notEqual funct3 0

    # funct12
    op shr funct12 instruction 20
    op mod funct12 funct12 4096 # 2^12 (trunc 12)

    jump ECALL equal funct12 0
    jump EBREAK equal funct12 1
    jump illegal_instruction always

decode_arithmetic_imm:
    # I-type
    op add ret @counter 1
    jump decode_type_I always

    jump ADDI equal funct3 0
    jump SLLI equal funct3 1
    jump SLTI equal funct3 2
    jump SLTIU equal funct3 3
    jump XORI equal funct3 4
    jump decode_SRLI_SRAI equal funct3 5
    jump ORI equal funct3 6
    jump ANDI equal funct3 7
    jump illegal_instruction always

decode_SRLI_SRAI:
    jump SRLI equal funct7 0
    jump SRAI equal funct7 32
    jump illegal_instruction always

decode_arithmetic:
    # R-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    jump decode_ADD_SUB equal funct3 0
    jump SLL equal funct3 1
    jump SLT equal funct3 2
    jump SLTU equal funct3 3
    jump XOR equal funct3 4
    jump decode_SRL_SRA equal funct3 5
    jump OR equal funct3 6
    jump AND equal funct3 7
    jump illegal_instruction always

decode_ADD_SUB:
    jump ADD equal funct7 0
    jump SUB equal funct7 32
    jump illegal_instruction always

decode_SRL_SRA:
    jump SRL equal funct7 0
    jump SRA equal funct7 32
    jump illegal_instruction always

# common decoder for I-type instructions
decode_type_I:
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 20
    op mod imm imm 4096 # 2^12 (trunc 12)

    set value imm
    set length 12
    set decode_type_I__ret ret
    op add ret @counter 1
    jump extend_sign always
    set imm result

    set @counter decode_type_I__ret

# common decoder for U-type instructions (only LUI and AUIPC)
decode_type_U:
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 12
    op mod imm imm 1048576 # 2^20 (trunc 20)
    op shl imm imm 12
    
    set @counter ret

illegal_instruction:
    print "Illegal instruction!"
    printflush ERROR_OUTPUT
    jump halt always

instruction_address_misaligned:
    print "Instruction address misaligned!"
    printflush ERROR_OUTPUT
    jump halt always

misaligned_load:
    print "Attempted misaligned load!"
    printflush ERROR_OUTPUT
    jump halt always

misaligned_store:
    print "Attempted misaligned store!"
    printflush ERROR_OUTPUT
    jump halt always

# enable the reset switch, wait until it's disabled, then reset the processor
halt:
    control enabled RESET_SWITCH true
halt__loop:
    sensor enabled RESET_SWITCH @enabled
    jump halt__loop equal enabled true
    jump reset always

end_instruction:
    op add pc pc 4
end_instruction_preserve_pc:
    # halt if the reset switch was manually enabled
    sensor enabled RESET_SWITCH @enabled
    jump halt equal enabled true
    jump main always

# helper functions

# sign extension function
# value, length -> result
extend_sign:
    op sub _shift length 1
    op shr _sign value _shift
    jump extend_sign__zero equal _sign 0

    # sign is 1, return ((2^(32-length) - 1) << length) + value
    op sub _mask 32 length
    op pow _mask 2 _mask
    op sub _mask _mask 1
    op shl _mask _mask length

    op add result value _mask

    jump extend_sign__finally always

extend_sign__zero:
    # sign is 0, return value unchanged
    set result value

extend_sign__finally:
    set @counter ret

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# value -> result
swap_endianness:
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl _tmp value 8
    op and _tmp _tmp 0xff0000
    op or result result _tmp

    # byte 2 -> byte 1
    op shr _tmp value 8
    op and _tmp _tmp 0xff00
    op or result result _tmp

    # byte 0 -> byte 3
    op shl _tmp value 24
    op and _tmp _tmp 0xff000000
    op or result result _tmp

    set @counter ret

# converts a pair of two's complement unsigned values to signed, or vice versa
# this converts two values at once because every usage of it needs to convert two values
# value1, value2 -> result1, result2
swap_signedness:
    # x - 2(x - mod(x + 2^31, 2^31))
    op add result1 value1 0x80000000 # 2^31
    op mod result1 result1 0x80000000
    op sub result1 value1 result1
    op mul result1 result1 2
    op sub result1 value1 result1

    op add result2 value2 0x80000000 # 2^31
    op mod result2 result2 0x80000000
    op sub result2 value2 result2
    op mul result2 result2 2
    op sub result2 value2 result2

    set @counter ret

# loads the word from memory that contains the specified address
# address -> result
load_word:
    op idiv _index address 4
    read value MEMORY _index

    # tail call, swap_endianness will jump to the ret value of load_word's caller
    jump swap_endianness always

# loads a value with a specified length in bits (8, 16, or 32) from memory
# raises a misaligned-load exception if the address is misaligned for the specified length
# address, length, is_signed -> result
load_value:
    set load_value__ret ret

    # truncate address, because every caller needs to do it anyway
    op mod address address 0x100000000 # 2^32 (trunc 32)

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    jump misaligned_load notEqual _alignment 0

    # load the word containing the address
    op add ret @counter 1
    jump load_word always

    # right shift by (address % 4) bits
    op mod _shift address 4
    op mul _shift _shift 8
    op shr result result _shift

    # truncate to the specified number of bits
    op pow _divisor 2 length
    op mod result result _divisor

    # extend the sign of the value if it's signed
    set value result
    set ret load_value__ret
    jump extend_sign equal is_signed true # tail call

    set @counter load_value__ret

# stores a word to memory at the specified address
# NOTE: does not perform an alignment check
# address, value ->
store_word:
    set store_word__ret ret
    
    op add ret @counter 1
    jump swap_endianness always

    op idiv _index address 4
    write result MEMORY _index

    set @counter store_word__ret

# stores a value with a specified length in bits (8, 16, or 32) to memory
# raises a misaligned-store exception if the address is misaligned for the specified length
# address, value, length ->
store_value:
    set store_value__ret ret

    # truncate address, because every caller needs to do it anyway
    op mod address address 0x100000000 # 2^32 (trunc 32)

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    jump misaligned_store notEqual _alignment 0

    # create a bitmask with 0 in the section we want to replace and 1 everywhere else
    op mod _shift address 4
    op mul _shift _shift 8

    op pow _bitmask 2 length
    op sub _bitmask _bitmask 1
    op shl _bitmask _bitmask _shift
    op sub _bitmask 0xffffffff _bitmask

    # take the low n bits of the value to store, and shift it to line up with the zeros in the mask
    op pow _divisor 2 length
    op mod _value value _divisor
    op shl _value _value _shift

    # load the word containing the address
    op add ret @counter 1
    jump load_word always

    # insert the value into the word
    op and result result _bitmask
    op add value _value result

    # store the final word (tail call)
    set ret store_value__ret
    jump store_word always

# instruction handlers

LUI:
    op add ret @counter 1
    jump decode_type_U always

    jump end_instruction equal rd 0
    write imm REGISTERS rd
    jump end_instruction always

AUIPC:
    op add ret @counter 1
    jump decode_type_U always
    
    jump end_instruction equal rd 0

    op add result imm pc
    op mod result result 0x100000000 # trunc 32
    write result REGISTERS rd

    jump end_instruction always

JAL:
    # J-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm_19_12 instruction 12
    op shr imm_11 imm_19_12 8
    op shr imm_10_1 imm_11 1
    op shr imm_20 imm_10_1 10

    op mod imm_19_12 imm_19_12 256 # 2^8 (trunc 8)
    op shl imm_19_12 imm_19_12 12

    op mod imm_11 imm_11 2 # 2^1 (trunc 1)
    op shl imm_11 imm_11 11

    op mod imm_10_1 imm_10_1 1024 # 2^10 (trunc 10)
    op shl imm_10_1 imm_10_1 1

    op mod imm_20 imm_20 2 # 2^1 (trunc 1)
    op shl imm_20 imm_20 20

    op add imm imm_10_1 imm_11
    op add imm imm imm_19_12
    op add imm imm imm_20

    set value imm
    set length 21
    op add ret @counter 1
    jump extend_sign always
    set imm result

    # instruction handler

    op add target pc imm

jump_to_target:
    op mod target target 0x100000000 # trunc 32

    op mod remainder target 4
    jump instruction_address_misaligned notEqual remainder 0

    jump jump_to_target__no_write equal rd 0

    op add result pc 4
    op mod result result 0x100000000 # trunc 32
    write result REGISTERS rd

jump_to_target__no_write:
    set pc target
    jump end_instruction_preserve_pc always

JALR:
    op add ret @counter 1
    jump decode_type_I always

    op add target rs1 imm
    jump jump_to_target always

BEQ:
    op add target pc imm
    set rd 0
    jump jump_to_target equal rs1 rs2
    jump end_instruction always

BNE:
    op add target pc imm
    set rd 0
    jump jump_to_target notEqual rs1 rs2
    jump end_instruction always

BLT:
    set value1 rs1
    set value2 rs2
    op add ret @counter 1
    jump swap_signedness always

    op add target pc imm
    set rd 0
    jump jump_to_target lessThan result1 result2
    jump end_instruction always

BGE:
    set value1 rs1
    set value2 rs2
    op add ret @counter 1
    jump swap_signedness always

    op add target pc imm
    set rd 0
    jump jump_to_target greaterThanEq result1 result2
    jump end_instruction always

BLTU:
    op add target pc imm
    set rd 0
    jump jump_to_target lessThan rs1 rs2
    jump end_instruction always

BGEU:
    op add target pc imm
    set rd 0
    jump jump_to_target greaterThanEq rs1 rs2
    jump end_instruction always

LB:
    op add address rs1 imm
    set length 8
    set is_signed true
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LH:
    op add address rs1 imm
    set length 16
    set is_signed true
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LW:
    op add address rs1 imm
    set length 32
    set is_signed false
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LBU:
    op add address rs1 imm
    set length 8
    set is_signed false
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LHU:
    op add address rs1 imm
    set length 16
    set is_signed false
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

SB:
    op add address rs1 imm
    set value rs2
    set length 8
    op add ret @counter 1
    jump store_value always
    jump end_instruction always

SH:
    op add address rs1 imm
    set value rs2
    set length 16
    op add ret @counter 1
    jump store_value always
    jump end_instruction always

SW:
    op add address rs1 imm
    set value rs2
    set length 32
    op add ret @counter 1
    jump store_value always
    jump end_instruction always

ADDI:
    jump end_instruction equal rd 0

    op add result rs1 imm
    op mod result result 0x100000000 # 2^32 (trunc 32)
    write result REGISTERS rd

    jump end_instruction always

SLTI:
    jump end_instruction equal rd 0

    set value1 rs1
    set value2 imm
    op add ret @counter 1
    jump swap_signedness always

    op lessThan result result1 result2
    write result REGISTERS rd

    jump end_instruction always

SLTIU:
    jump end_instruction equal rd 0

    op lessThan result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

XORI:
    jump end_instruction equal rd 0

    op xor result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

ORI:
    jump end_instruction equal rd 0

    op or result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

ANDI:
    jump end_instruction equal rd 0

    op and result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

SLLI:
    # put the check here because there are no other instructions with this opcode and funct3
    jump illegal_instruction notEqual funct7 0

    jump end_instruction equal rd 0

    op mod imm imm 32 # 2^5 (trunc 5)

    # truncate before shifting to avoid overflowing 52 integer bits in double
    op sub length 32 imm
    op pow divisor 2 length
    op mod rs1 rs1 divisor

    op shl result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

SRLI:
    jump end_instruction equal rd 0

    op mod imm imm 32 # 2^5 (trunc 5)

    op shr result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

SRAI:
    jump end_instruction equal rd 0

    op mod imm imm 32 # 2^5 (trunc 5)

    op shr value rs1 imm

    op sub length 32 imm
    op add ret @counter 1
    jump extend_sign always

    write result REGISTERS rd

    jump end_instruction always

# most of the register-register instructions are identical to their register-immediate counterparts
# so just set imm to rs2 and reuse the existing logic

ADD:
    set imm rs2
    jump ADDI always

SUB:
    # apply two's complement to negate the value in rs2 and put it into imm
    op sub imm 0x100000000 rs2
    op mod imm imm 0x100000000

    jump ADDI always

SLL:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump SLLI always

SLT:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump SLTI always

SLTU:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump SLTIU always

XOR:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump XORI always

SRL:
    set imm rs2
    jump SRLI always

SRA:
    set imm rs2
    jump SRAI always

OR:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump ORI always

AND:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump ANDI always

FENCE:
    jump illegal_instruction notEqual funct3 0

    # I-type, but without sign extension
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 20
    op mod imm imm 4096 # 2^12 (trunc 12)

    # PAUSE
    # TODO: there's probably a better way to do this
    jump FENCE__not_pause notEqual rd 0
    jump FENCE__not_pause notEqual rs1_id 0
    jump FENCE__not_pause notEqual imm 0b000000010000

    wait 0.00001

FENCE__not_pause:
    # no-op
    jump end_instruction always

ECALL:
    # TODO: implement syscalls
    jump end_instruction always

EBREAK:
    control enabled PAUSE_SWITCH true
    print "Paused on EBREAK, disable pause switch to continue"
    printflush ERROR_OUTPUT

EBREAK__loop:
    sensor reset_enabled RESET_SWITCH @enabled
    jump halt equal reset_enabled true
    sensor pause_enabled PAUSE_SWITCH @enabled
    jump EBREAK__loop equal pause_enabled true

    printflush ERROR_OUTPUT
    jump end_instruction always
