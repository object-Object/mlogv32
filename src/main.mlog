reset:
    # constants
    set ERROR_OUTPUT message1
    set RESET_SWITCH switch1
    set REGISTERS cell1
    set MEMORY bank1 # TODO: support multiple memory banks

    # initialization

    print ""
    printflush ERROR_OUTPUT

    control enabled RESET_SWITCH false

    set i 0
reset__zero_registers:
    write 0 REGISTERS i
    op add i i 1
    jump reset__zero_registers lessThan i 32

    set pc 0
    
main:
    # load instruction and convert to big endian
    op idiv address pc 4
    read value MEMORY address
    
    op add ret @counter 1
    jump swap_endianness always
    set instruction result

    # decode instruction

    op mod opcode instruction 128 # 2^7 (trunc 7)

    # instructions disambiguated by just the opcode

    jump LUI equal opcode 55
    jump AUIPC equal opcode 23
    jump JAL equal opcode 111
    jump SYSTEM equal opcode 115

    # all below instructions use rs1, so just decode and read it here
    op shr rs1 instruction 15
    op mod rs1 rs1 32 # 2^5 (trunc 5)
    read rs1 REGISTERS rs1

    jump JALR equal opcode 103
    jump FENCE equal opcode 15

    # instructions disambiguated by funct3

    op shr funct3 instruction 12
    op mod funct3 funct3 8 # 2^3 (trunc 3)
    
    jump decode_branch equal opcode 99
    jump decode_load equal opcode 3
    jump decode_save equal opcode 35

    # instructions disambiguated by funct7

    op shr funct7 instruction 25
    op mod funct7 funct7 128 # 2^7 (trunc 7)

    jump decode_arithmetic_imm equal opcode 19
    jump decode_arithmetic equal opcode 51

    # :(
    jump illegal_instruction always

decode_branch:
    # B-type
    # imm
    op shr imm_11 instruction 7
    op mod imm_11 imm_11 2 # 2^1 (trunc 1)
    op shl imm_11 imm_11 11

    op shr imm_4_1 instruction 8
    op mod imm_4_1 imm_4_1 16 # 2^4 (trunc 4)
    op shl imm_4_1 imm_4_1 1

    op shr imm_10_5 instruction 25
    op mod imm_10_5 imm_10_5 64 # 2^6 (trunc 6)
    op shl imm_10_5 imm_10_5 5

    op shr imm_12 instruction 31
    op mod imm_12 imm_12 2 # 2^1 (trunc 1)
    op shl imm_12 imm_12 12

    op add imm imm_4_1 imm_10_5
    op add imm imm imm_11
    op add imm imm imm_12

    set value imm
    set length 13
    op add ret @counter 1
    jump extend_sign always
    set imm result

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    jump BEQ equal funct3 0
    jump BNE equal funct3 1
    jump BLT equal funct3 4
    jump BGE equal funct3 5
    jump BLTU equal funct3 6
    jump BGEU equal funct3 7
    jump illegal_instruction always

decode_load:
    # I-type
    op add ret @counter 1
    jump decode_type_I always

    jump LB equal funct3 0
    jump LH equal funct3 1
    jump LW equal funct3 2
    jump LBU equal funct3 4
    jump LHU equal funct3 5
    jump illegal_instruction always

decode_save:
    # S-type
    # imm
    op shr imm_4_0 instruction 7
    op mod imm_4_0 imm_4_0 32 # 2^5 (trunc 5)

    op shr imm_11_5 instruction 25
    op mod imm_11_5 imm_11_5 128 # 2^7 (trunc 7)
    op shl imm_11_5 imm_11_5 5

    op add imm imm_4_0 imm_11_5

    set value imm
    set length 12
    op add ret @counter 1
    jump extend_sign always
    set imm result

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    jump SB equal funct3 0
    jump SH equal funct3 1
    jump SW equal funct3 2
    jump illegal_instruction always

decode_arithmetic_imm:
    # I-type
    op add ret @counter 1
    jump decode_type_I always

    jump ADDI equal funct3 0
    jump SLLI equal funct3 1
    jump SLTI equal funct3 2
    jump SLTIU equal funct3 3
    jump XORI equal funct3 4
    jump decode_SRLI_SRAI equal funct3 5
    jump ORI equal funct3 6
    jump ANDI equal funct3 7
    jump illegal_instruction always

decode_SRLI_SRAI:
    jump SRLI equal funct7 0
    jump SRAI equal funct7 32
    jump illegal_instruction always

decode_arithmetic:
    # R-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    jump decode_ADD_SUB equal funct3 0
    jump SLL equal funct3 1
    jump SLT equal funct3 2
    jump SLTU equal funct3 3
    jump XOR equal funct3 4
    jump decode_SRL_SRA equal funct3 5
    jump OR equal funct3 6
    jump AND equal funct3 7
    jump illegal_instruction always

decode_ADD_SUB:
    jump ADD equal funct7 0
    jump SUB equal funct7 32
    jump illegal_instruction always

decode_SRL_SRA:
    jump SRL equal funct7 0
    jump SRA equal funct7 32
    jump illegal_instruction always

# common decoder for I-type instructions
decode_type_I:
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 20
    op mod imm imm 4096 # 2^12 (trunc 12)

    set value imm
    set length 12
    set decode_type_I__ret ret
    op add ret @counter 1
    jump extend_sign always
    set imm result

    set @counter decode_type_I__ret

# common decoder for U-type instructions (only LUI and AUIPC)
decode_type_U:
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 12
    op mod imm imm 1048576 # 2^20 (trunc 20)
    op shl imm imm 12
    
    set @counter ret

illegal_instruction:
    print "Illegal instruction!"
    printflush ERROR_OUTPUT
    jump halt always

instruction_address_misaligned:
    print "Instruction address misaligned!"
    printflush ERROR_OUTPUT
    jump halt always

# enable the reset switch, wait until it's disabled, then reset the processor
halt:
    control enabled RESET_SWITCH true
halt__loop:
    sensor enabled RESET_SWITCH @enabled
    jump halt__loop equal enabled true
    jump reset always

end_instruction:
    op add pc pc 4
end_instruction_preserve_pc:
    # halt if the reset switch was manually enabled
    sensor enabled RESET_SWITCH @enabled
    jump halt equal enabled true
    jump main always

# helper functions

# sign extension function
# value, length -> result
extend_sign:
    op sub _shift length 1
    op shr _sign value _shift
    jump extend_sign__zero equal _sign 0

    # sign is 1, return ((2^(32-length) - 1) << length) + value
    op sub _mask 32 length
    op pow _mask 2 _mask
    op sub _mask _mask 1
    op shl _mask _mask length

    op add result value _mask

    jump extend_sign__finally always

extend_sign__zero:
    # sign is 0, return value unchanged
    set result value

extend_sign__finally:
    set @counter ret

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# value -> result
swap_endianness:
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl _tmp value 8
    op and _tmp _tmp 0xff0000
    op or result result _tmp

    # byte 2 -> byte 1
    op shr _tmp value 8
    op and _tmp _tmp 0xff00
    op or result result _tmp

    # byte 0 -> byte 3
    op shl _tmp value 24
    op and _tmp _tmp 0xff000000
    op or result result _tmp

    set @counter ret

# instruction handlers

LUI:
    op add ret @counter 1
    jump decode_type_U always

    print "LUI"
    printflush ERROR_OUTPUT
    jump end_instruction always

AUIPC:
    op add ret @counter 1
    jump decode_type_U always
    
    print "AUIPC"
    printflush ERROR_OUTPUT
    jump end_instruction always

JAL:
    # J-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm_19_12 instruction 12
    op shr imm_11 imm_19_12 8
    op shr imm_10_1 imm_11 1
    op shr imm_20 imm_10_1 10

    op mod imm_19_12 imm_19_12 256 # 2^8 (trunc 8)
    op shl imm_19_12 imm_19_12 12

    op mod imm_11 imm_11 2 # 2^1 (trunc 1)
    op shl imm_11 imm_11 11

    op mod imm_10_1 imm_10_1 1024 # 2^10 (trunc 10)
    op shl imm_10_1 imm_10_1 1

    op mod imm_20 imm_20 2 # 2^1 (trunc 1)
    op shl imm_20 imm_20 20

    op add imm imm_10_1 imm_11
    op add imm imm imm_19_12
    op add imm imm imm_20

    set value imm
    set length 21
    op add ret @counter 1
    jump extend_sign always
    set imm result

    # instruction handler

    op add target pc imm

jump_to_target:
    op mod target target 0x100000000 # trunc 32

    op mod remainder target 4
    jump instruction_address_misaligned notEqual remainder 0

    op add result pc 4
    op mod result result 0x100000000 # trunc 32

    set pc target

    jump end_instruction_preserve_pc equal rd 0
    write result REGISTERS rd
    jump end_instruction_preserve_pc always

JALR:
    op add ret @counter 1
    jump decode_type_I always

    op add target rs1 imm
    jump jump_to_target always

BEQ:
    print "BEQ"
    printflush ERROR_OUTPUT
    jump end_instruction always

BNE:
    print "BNE"
    printflush ERROR_OUTPUT
    jump end_instruction always

BLT:
    print "BLT"
    printflush ERROR_OUTPUT
    jump end_instruction always

BGE:
    print "BGE"
    printflush ERROR_OUTPUT
    jump end_instruction always

BLTU:
    print "BLTU"
    printflush ERROR_OUTPUT
    jump end_instruction always

BGEU:
    print "BGEU"
    printflush ERROR_OUTPUT
    jump end_instruction always

LB:
    print "LB"
    printflush ERROR_OUTPUT
    jump end_instruction always

LH:
    print "LH"
    printflush ERROR_OUTPUT
    jump end_instruction always

LW:
    print "LW"
    printflush ERROR_OUTPUT
    jump end_instruction always

LBU:
    print "LBU"
    printflush ERROR_OUTPUT
    jump end_instruction always

LHU:
    print "LHU"
    printflush ERROR_OUTPUT
    jump end_instruction always

SB:
    print "SB"
    printflush ERROR_OUTPUT
    jump end_instruction always

SH:
    print "SH"
    printflush ERROR_OUTPUT
    jump end_instruction always

SW:
    print "SW"
    printflush ERROR_OUTPUT
    jump end_instruction always

ADDI:
    jump end_instruction equal rd 0

    op add result rs1 imm
    op mod result result 0x100000000 # 2^32 (trunc 32)
    write result REGISTERS rd

    jump end_instruction always

SLTI:
    print "SLTI"
    printflush ERROR_OUTPUT
    jump end_instruction always

SLTIU:
    print "SLTIU"
    printflush ERROR_OUTPUT
    jump end_instruction always

XORI:
    print "XORI"
    printflush ERROR_OUTPUT
    jump end_instruction always

ORI:
    print "ORI"
    printflush ERROR_OUTPUT
    jump end_instruction always

ANDI:
    print "ANDI"
    printflush ERROR_OUTPUT
    jump end_instruction always

SLLI:
    # put the check here because there are no other instructions with this opcode and funct3
    jump illegal_instruction notEqual funct7 0

    print "SLLI"
    printflush ERROR_OUTPUT
    jump end_instruction always

SRLI:
    print "SRLI"
    printflush ERROR_OUTPUT
    jump end_instruction always

SRAI:
    print "SRAI"
    printflush ERROR_OUTPUT
    jump end_instruction always

ADD:
    jump end_instruction equal rd 0

    op add result rs1 rs2
    op mod result result 0x100000000 # 2^32 (trunc 32)
    write result REGISTERS rd

    jump end_instruction always

SUB:
    print "SUB"
    printflush ERROR_OUTPUT
    jump end_instruction always

SLL:
    jump illegal_instruction notEqual funct7 0

    print "SLL"
    printflush ERROR_OUTPUT
    jump end_instruction always

SLT:
    jump illegal_instruction notEqual funct7 0

    print "SLT"
    printflush ERROR_OUTPUT
    jump end_instruction always

SLTU:
    jump illegal_instruction notEqual funct7 0

    print "SLTU"
    printflush ERROR_OUTPUT
    jump end_instruction always

XOR:
    jump illegal_instruction notEqual funct7 0

    print "XOR"
    printflush ERROR_OUTPUT
    jump end_instruction always

SRL:
    print "SRL"
    printflush ERROR_OUTPUT
    jump end_instruction always

SRA:
    print "SRA"
    printflush ERROR_OUTPUT
    jump end_instruction always

OR:
    jump illegal_instruction notEqual funct7 0

    print "OR"
    printflush ERROR_OUTPUT
    jump end_instruction always

AND:
    jump illegal_instruction notEqual funct7 0

    print "AND"
    printflush ERROR_OUTPUT
    jump end_instruction always

FENCE:
    op add ret @counter 1
    jump decode_type_I always

    print "FENCE"
    printflush ERROR_OUTPUT
    jump end_instruction always

SYSTEM:
    op add ret @counter 1
    jump decode_type_I always

    print "SYSTEM"
    printflush ERROR_OUTPUT
    jump end_instruction always
