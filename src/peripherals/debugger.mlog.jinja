#% set LOOKUP_PROC_SIZE = 260
#% set ROM_BYTE_OFFSET = 174
#% set ROM_PROC_BYTES = 16384
#% set RAM_PROC_VARS = 4096
#% set ROM_START = '0x00000000'
#% set RAM_START = '0x80000000'

#% set CPU = 'processor17'
#% set CSRS = 'processor18'
#% set REGISTERS = 'cell1'
#% set DISPLAY = 'display1'
#% set SWITCH = 'switch1'
#% set UART0 = 'bank1'
#% set UART1 = 'bank2'
#% set UART2 = 'bank3'
#% set UART3 = 'bank4'

#% macro print(col, row)
   #{{'\n'}}    draw print {{ 11 + col * 7 }} {{ 512 - 6 - row * 13 }} topLeft
    drawflush {{DISPLAY}}
#% endmacro

#% macro rect(col, row, width, height)
   #{{'\n'}}    draw rect {{ 11 + col * 7 }} {{ 512 - 6 - row * 13 - 3 }} {{ width * 7 }} {{ height * -13 }}
#% endmacro

reset:
    setrate 5000
    set MARKER_START_ID 0

    op add i MARKER_START_ID 6
reset_markers:
    op sub i i 1
    setmarker remove i
    jump reset_markers greaterThan i MARKER_START_ID

reset_loop:
    wait 1e-5
    sensor enabled {{SWITCH}} @enabled
    jump reset_loop equal enabled false

    set i -1
reset__find_lookup_start:
    op add i i 1
    getlink block i
    sensor type block @type
    jump reset__find_lookup_start notEqual type @micro-processor
    read type_var block "_type"
    jump reset__find_lookup_start notEqual type_var "lookup"

    control enabled {{SWITCH}} true

    draw reset
    draw color 255 255 255 255
    draw clear 0 0 0
    drawflush {{DISPLAY}}

    print "x0  (zero)  =\n"
    print "x1  (ra)    =\n"
    print "x2  (sp)    =\n"
    print "x3  (gp)    =\n"
    print "x4  (tp)    =\n"
    print "x5  (t0)    =\n"
    print "x6  (t1)    =\n"
    print "x7  (t2)    =\n"
    print "x8  (s0/fp) =\n"
    print "x9  (s1)    =\n"
    print "x10 (a0)    =\n"
    print "x11 (a1)    =\n"
    print "x12 (a2)    =\n"
    print "x13 (a3)    =\n"
    print "x14 (a4)    =\n"
    print "x15 (a5)    =\n"

    #{ print(0, 0)

    print "x16 (a6)  =\n"
    print "x17 (a7)  =\n"
    print "x18 (s2)  =\n"
    print "x19 (s3)  =\n"
    print "x20 (s4)  =\n"
    print "x21 (s5)  =\n"
    print "x22 (s6)  =\n"
    print "x23 (s7)  =\n"
    print "x24 (s8)  =\n"
    print "x25 (s9)  =\n"
    print "x26 (s10) =\n"
    print "x27 (s11) =\n"
    print "x28 (t3)  =\n"
    print "x29 (t4)  =\n"
    print "x30 (t5)  =\n"
    print "x31 (t6)  =\n"

    #{ print(35, 0)

loop:
    sensor enabled {{SWITCH}} @enabled
    jump reset equal enabled false

    set mark_memory_id MARKER_START_ID

    read MEMORY_X {{CPU}} "MEMORY_X"
    read MEMORY_Y {{CPU}} "MEMORY_Y"
    read MEMORY_WIDTH {{CPU}} "MEMORY_WIDTH"

    read PROGRAM_ROM_SIZE {{CPU}} "PROGRAM_ROM_SIZE"
    read DATA_ROM_SIZE {{CPU}} "DATA_ROM_SIZE"
    read ROM_SIZE {{CPU}} "ROM_SIZE"
    read ICACHE_SIZE {{CPU}} "ICACHE_SIZE"

    read RAM_START_PROC {{CPU}} "RAM_START_PROC"
    read RAM_END {{CPU}} "RAM_END"

    set ICACHE_START RAM_END
    op add ICACHE_END ICACHE_START ICACHE_SIZE

    read x0 {{REGISTERS}} 0
    read x1 {{REGISTERS}} 1
    read x2 {{REGISTERS}} 2
    read x3 {{REGISTERS}} 3
    read x4 {{REGISTERS}} 4
    read x5 {{REGISTERS}} 5
    read x6 {{REGISTERS}} 6
    read x7 {{REGISTERS}} 7
    read x8 {{REGISTERS}} 8
    read x9 {{REGISTERS}} 9
    read x10 {{REGISTERS}} 10
    read x11 {{REGISTERS}} 11
    read x12 {{REGISTERS}} 12
    read x13 {{REGISTERS}} 13
    read x14 {{REGISTERS}} 14
    read x15 {{REGISTERS}} 15
    read x16 {{REGISTERS}} 16
    read x17 {{REGISTERS}} 17
    read x18 {{REGISTERS}} 18
    read x19 {{REGISTERS}} 19
    read x20 {{REGISTERS}} 20
    read x21 {{REGISTERS}} 21
    read x22 {{REGISTERS}} 22
    read x23 {{REGISTERS}} 23
    read x24 {{REGISTERS}} 24
    read x25 {{REGISTERS}} 25
    read x26 {{REGISTERS}} 26
    read x27 {{REGISTERS}} 27
    read x28 {{REGISTERS}} 28
    read x29 {{REGISTERS}} 29
    read x30 {{REGISTERS}} 30
    read x31 {{REGISTERS}} 31
    
    read mcycle {{CSRS}} "{{ 'mcycle'|csr }}"
    read mcycleh {{CSRS}} "{{ 'mcycleh'|csr }}"
    op shl mcycleh mcycleh 32
    op add mcycle mcycle mcycleh
    
    read mtime {{CPU}} "csr_mtime"
    read mtimeh {{CPU}} "csr_mtimeh"
    op shl mtimeh mtimeh 32
    op add mtime mtime mtimeh
    
    read mtimecmp {{CPU}} "csr_mtimecmp"
    read mtimecmph {{CPU}} "csr_mtimecmph"
    op shl mtimecmph mtimecmph 32
    op add mtimecmp mtimecmp mtimecmph
    
    read minstret {{CPU}} "csr_minstret"
    read minstreth {{CPU}} "csr_minstreth"
    op shl minstreth minstreth 32
    op add minstret minstret minstreth

    read satp {{CPU}} "csr_satp"
    read sscratch {{CSRS}} "{{ 'sscratch'|csr }}"
    read stvec {{CSRS}} "{{ 'stvec'|csr }}"
    read sepc {{CSRS}} "{{ 'sepc'|csr }}"
    read scause {{CSRS}} "{{ 'scause'|csr }}"
    read stval {{CSRS}} "{{ 'stval'|csr }}"

    read mscratch {{CSRS}} "{{ 'mscratch'|csr }}"
    read mtvec {{CSRS}} "{{ 'mtvec'|csr }}"
    read mepc {{CSRS}} "{{ 'mepc'|csr }}"
    read mcause {{CSRS}} "{{ 'mcause'|csr }}"
    read mtval {{CSRS}} "{{ 'mtval'|csr }}"

    read mstatus {{CPU}} "csr_mstatus"
    read mip {{CPU}} "csr_mip"
    read mie {{CPU}} "csr_mie"

    read state {{CPU}} "state"
    read pc {{CPU}} "pc"
    read op_id {{CPU}} "op_id"
    read rs1 {{CPU}} "rs1_id"
    read rs2 {{CPU}} "rs2_id"
    read rd {{CPU}} "rd_id"
    read imm {{CPU}} "imm"

    read __etext {{CPU}} "__etext"
    read reservation_set {{CPU}} "reservation_set"
    read privilege_mode {{CPU}} "privilege_mode"
    read effective_privilege_mode {{CPU}} "effective_privilege_mode"

    read UART_FIFO_MODULO {{CPU}} "UART_FIFO_MODULO"
    op sub UART_FIFO_CAPACITY UART_FIFO_MODULO 1

    # markers

    print "PROGRAM_ROM_START\n{0}"
    set address {{ROM_START}}
    op add ret @counter 1
    jump mark_memory always

    print "PROGRAM_ROM_END\n{0}"
    op sub address PROGRAM_ROM_SIZE 1
    op add ret @counter 1
    jump mark_memory always

    setmarker remove mark_memory_id
    op add tmp mark_memory_id 1
    setmarker remove tmp
    jump loop__no_mark_data_rom lessThanEq DATA_ROM_SIZE 0

    print "DATA_ROM_START\n{0}"
    set address PROGRAM_ROM_SIZE
    op add ret @counter 1
    jump mark_memory always

    print "DATA_ROM_END\n{0}"
    op sub address ROM_SIZE 1
    op add ret @counter 1
    jump mark_memory always

loop__no_mark_data_rom:

    print "RAM_START\n{0}"
    set address {{RAM_START}}
    op add ret @counter 1
    jump mark_memory always

    print "RAM_END\n{0}"
    op sub address RAM_END 1
    op add ret @counter 1
    jump mark_memory always

    setmarker remove mark_memory_id
    op add tmp mark_memory_id 1
    setmarker remove tmp
    jump loop__no_mark_icache lessThanEq ICACHE_SIZE 0

    print "ICACHE_START\n{0}"
    set address ICACHE_START
    op add ret @counter 1
    jump mark_memory always

    print "ICACHE_END\n{0}"
    op sub address ICACHE_END 1
    op add ret @counter 1
    jump mark_memory always
loop__no_mark_icache:

    # clear

    draw color 0 0 0 255
    #{ rect(14, 0, 10, 16)
    #{ rect(47, 0, 10, 16)
    #{ rect(0, 17, 73, 22)
    draw color 255 255 255 255

    # column 1

    print "{0}\n"
    set n x0
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x1
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x2
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x3
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x4
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x5
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x6
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x7
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x8
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x9
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x10
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x11
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x12
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x13
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x14
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x15
    op add ret @counter 1
    jump format_hex always

    #{ print(14, 0)

    print "pc    = {0}\n"
    set n pc
    op add ret @counter 1
    jump format_hex always

    print "op_id = {0}\n"
    print "imm   = {1}\n"
    print "rs1   = {2}\n"
    print "rs2   = {3}\n"
    print "rd    = {4}\n\n"
    op add ret2 @counter 1
    jump format_op_id always

    #{ print(0, 17)

    print "mtvec    = {0}\n"
    set n mtvec
    op add ret @counter 1
    jump format_hex always

    print "mepc     = {0}\n"
    set n mepc
    op add ret @counter 1
    jump format_hex always

    print "mcause   = {0}\n"
    set n mcause
    op add ret @counter 1
    jump format_mcause always

    print "mtval    = {0}\n"
    set n mtval
    op add ret @counter 1
    jump format_hex always

    print "mscratch = {0}\n\n"
    set n mscratch
    op add ret @counter 1
    jump format_hex always

    print "mstatus  = {0}\n"
    set n mstatus
    op add ret @counter 1
    jump format_bin always

    print "mip      = {0}\n"
    set n mip
    op add ret @counter 1
    jump format_bin always

    print "mie      = {0}\n"
    set n mie
    op add ret @counter 1
    jump format_bin always

    #{ print(0, 24)

    print "mtimecmp = {0}\n"
    format mtimecmp

    print "mtime    = {0}\n"
    format mtime

    print "mcycle   = {0}\n"
    format mcycle

    print "minstret = {0}\n"
    format minstret

    #{ print(0, 34)

    # column 2

    print "{0}\n"
    set n x16
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x17
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x18
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x19
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x20
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x21
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x22
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x23
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x24
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x25
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x26
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x27
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x28
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x29
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x30
    op add ret @counter 1
    jump format_hex always

    print "{0}\n"
    set n x31
    op add ret @counter 1
    jump format_hex always

    #{ print(47, 0)

    print "state           = {0}\n"
    format state

    print "__etext         = {0}\n"
    set n __etext
    op add ret @counter 1
    jump format_hex always

    print "reservation_set = {0}\n"
    set n reservation_set
    op add ret @counter 1
    jump format_hex always

    print "privilege_mode  = {0}\n"
    set n privilege_mode
    op add ret @counter 1
    jump format_privilege_mode always

    print "effective_mode  = {0}\n\n"
    set n effective_privilege_mode
    op add ret @counter 1
    jump format_privilege_mode always

    print "satp     = {0}\n"
    set n satp
    op add ret @counter 1
    jump format_hex always

    print "stvec    = {0}\n"
    set n stvec
    op add ret @counter 1
    jump format_hex always

    print "sepc     = {0}\n"
    set n sepc
    op add ret @counter 1
    jump format_hex always

    print "scause   = {0}\n"
    set n scause
    op add ret @counter 1
    jump format_mcause always

    print "stval    = {0}\n"
    set n stval
    op add ret @counter 1
    jump format_hex always

    print "sscratch = {0}\n"
    set n sscratch
    op add ret @counter 1
    jump format_hex always

    #{ print(35, 17)

    set uart {{UART0}}
    set uart_index 0
    op add ret @counter 1
    jump format_uart always

    set uart {{UART1}}
    set uart_index 1
    op add ret @counter 1
    jump format_uart always

    set uart {{UART2}}
    set uart_index 2
    op add ret @counter 1
    jump format_uart always

    set uart {{UART3}}
    set uart_index 3
    op add ret @counter 1
    jump format_uart always

    #{ print(30, 34)

    wait 0.02
    jump loop always

format_hex:
    jump format_null strictEqual n null
    op floor n n
    op and n n 0xffffffff # in case we get a negative value
format_hex__loop:
    op mod digit n 16
    op mul skip digit 2
    op add @counter @counter skip
    format "{0}0"
    jump format_hex__next always
    format "{0}1"
    jump format_hex__next always
    format "{0}2"
    jump format_hex__next always
    format "{0}3"
    jump format_hex__next always
    format "{0}4"
    jump format_hex__next always
    format "{0}5"
    jump format_hex__next always
    format "{0}6"
    jump format_hex__next always
    format "{0}7"
    jump format_hex__next always
    format "{0}8"
    jump format_hex__next always
    format "{0}9"
    jump format_hex__next always
    format "{0}A"
    jump format_hex__next always
    format "{0}B"
    jump format_hex__next always
    format "{0}C"
    jump format_hex__next always
    format "{0}D"
    jump format_hex__next always
    format "{0}E"
    jump format_hex__next always
    format "{0}F"
format_hex__next:
    op shr n n 4
    jump format_hex__loop greaterThan n 0
    format "0x"
    set @counter ret

format_bin:
    jump format_null strictEqual n null
    set i 0
    op floor n n
    op and n n 0xffffffff
format_bin__loop:
    op mod digit n 2
    op mul skip digit 2
    op add @counter @counter skip
    format "{0}0"
    jump format_bin__next always
    format "{0}1"
format_bin__next:
    op shr n n 1
    op add i i 1
    jump format_bin__loop lessThan i 32
    format "0b"
    set @counter ret

# format order: op_id, imm, rs1, rs2, rd
format_op_id:
    jump format_op_id__unknown strictEqual op_id null
    jump format_op_id__unknown lessThan op_id -64
    jump format_op_id__unknown greaterThan op_id 1
    op add jump op_id 64
    op mul jump jump 2
    op add @counter @counter jump
    format "BEQ";           jump format_op_id__B-type always
    format "BNE";           jump format_op_id__B-type always
    format "JAL";           jump format_op_id__J-type always
    format "JALR";          jump format_op_id__I-type always
    format "BLT";           jump format_op_id__B-type always
    format "BGE";           jump format_op_id__B-type always
    format "BLTU";          jump format_op_id__B-type always
    format "BGEU";          jump format_op_id__B-type always
    format "LB";            jump format_op_id__I-type always
    format "LH";            jump format_op_id__I-type always
    format "LW";            jump format_op_id__I-type always
    format "LUI";           jump format_op_id__U-type always
    format "LBU";           jump format_op_id__I-type always
    format "LHU";           jump format_op_id__I-type always
    format "SB";            jump format_op_id__S-type always
    format "SH";            jump format_op_id__S-type always
    format "SW";            jump format_op_id__S-type always
    format "AMOADD.W";      jump format_op_id__R-type always
    format "AMOSWAP.W";     jump format_op_id__R-type always
    format "LR.W";          jump format_op_id__R-type always
    format "SC.W";          jump format_op_id__R-type always
    format "AMOXOR.W";      jump format_op_id__R-type always
    format "AMOOR.W";       jump format_op_id__R-type always
    format "AMOAND.W";      jump format_op_id__R-type always
    format "AMOMIN.W";      jump format_op_id__R-type always
    format "AMOMAX.W";      jump format_op_id__R-type always
    format "AMOMINU.W";     jump format_op_id__R-type always
    format "AMOMAXU.W";     jump format_op_id__R-type always
    format "ADDI";          jump format_op_id__I-type always
    format "SUB";           jump format_op_id__R-type always
    format "SLTI";          jump format_op_id__I-type always
    format "SLTIU";         jump format_op_id__I-type always
    format "XORI";          jump format_op_id__I-type always
    format "SRA";           jump format_op_id__R-type always
    format "ORI";           jump format_op_id__I-type always
    format "ANDI";          jump format_op_id__I-type always
    format "ADD";           jump format_op_id__R-type always
    format "SLL";           jump format_op_id__R-type always
    format "SLT";           jump format_op_id__R-type always
    format "SLTU";          jump format_op_id__R-type always
    format "XOR";           jump format_op_id__R-type always
    format "SRL";           jump format_op_id__R-type always
    format "OR";            jump format_op_id__R-type always
    format "AND";           jump format_op_id__R-type always
    format "MUL";           jump format_op_id__R-type always
    format "MULH";          jump format_op_id__R-type always
    format "MULHSU";        jump format_op_id__R-type always
    format "MULHU";         jump format_op_id__R-type always
    format "DIV";           jump format_op_id__R-type always
    format "DIVU";          jump format_op_id__R-type always
    format "REM";           jump format_op_id__R-type always
    format "REMU";          jump format_op_id__R-type always
    jump format_op_id__priv always; stop
    format "CSRRW";         jump format_op_id__I-type always
    format "CSRRS";         jump format_op_id__I-type always
    format "CSRRC";         jump format_op_id__I-type always
    format "AUIPC";         jump format_op_id__U-type always
    format "CSRRWI";        jump format_op_id__I-type always
    format "CSRRSI";        jump format_op_id__I-type always
    format "CSRRCI";        jump format_op_id__I-type always
    format "FENCE";         jump format_op_id__I-type always
    format "SLLI";          jump format_op_id__I-type always
    format "SRLI";          jump format_op_id__I-type always
    format "SRAI";          jump format_op_id__I-type always
    format "ILLEGAL_OP";    jump format_op_id__empty always
    format "MLOGSYS";       jump format_op_id__I-type always

format_op_id__priv:
    op shr funct7 imm 5
    set name "ECALL";       jump format_op_id__priv__ok equal imm 0b000000000000
    set name "EBREAK";      jump format_op_id__priv__ok equal imm 0b000000000001
    set name "SRET";        jump format_op_id__priv__ok equal imm 0b000100000010
    set name "MRET";        jump format_op_id__priv__ok equal imm 0b001100000010
    set name "WFI";         jump format_op_id__priv__ok equal imm 0b000100000101
    set name "SFENCE.VMA";  jump format_op_id__priv__ok equal funct7 0b0001001
    jump format_op_id__unknown always
format_op_id__priv__ok:
    format name
    jump format_op_id__I-type always

format_op_id__unknown:
    format op_id
    set n imm; op add ret @counter 1; jump format_hex always
    format rs1
    format rs2
    format rd
    set @counter ret2

format_op_id__empty:
    format ""
    format ""
    format ""
    format ""
    set @counter ret2

format_op_id__R-type:
    format ""
    format rs1
    format rs2
    format rd
    set @counter ret2

format_op_id__I-type:
    set n imm; op add ret @counter 1; jump format_hex always
    format rs1
    format ""
    format rd
    set @counter ret2

format_op_id__S-type:
    set n imm; op add ret @counter 1; jump format_hex always
    format rs1
    format rs2
    format ""
    set @counter ret2

format_op_id__B-type:
    set n imm; op add ret @counter 1; jump format_hex always
    format rs1
    format rs2
    format ""
    set @counter ret2

format_op_id__U-type:
format_op_id__J-type:
    set n imm; op add ret @counter 1; jump format_hex always
    format ""
    format ""
    format rd
    set @counter ret2

format_unknown:
    format n
    set @counter ret

format_null:
    format "null"
    set @counter ret

# uart, uart_index ->
format_uart:
    read rx_rptr uart 254
    read rx_wptr_raw uart 255
    read tx_rptr uart 510
    read tx_wptr uart 511

    op and rx_wptr rx_wptr_raw 0xff

    op sub rx_fifo_size rx_wptr rx_rptr
    op add rx_fifo_size rx_fifo_size UART_FIFO_MODULO
    op mod rx_fifo_size rx_fifo_size UART_FIFO_MODULO

    op sub tx_fifo_size tx_wptr tx_rptr
    op add tx_fifo_size tx_fifo_size UART_FIFO_MODULO
    op mod tx_fifo_size tx_fifo_size UART_FIFO_MODULO

    op equal rx_full rx_fifo_size UART_FIFO_CAPACITY
    op notEqual rx_overflow_flag rx_wptr rx_wptr_raw
    op land rx_overrun rx_full rx_overflow_flag

    print "uart{0}: rx={1}"
    jump format_uart__rx_fifo_size__no_overrun notEqual rx_overrun true
    print "!"
    jump format_uart__rx_fifo_size__no_overrun__done always
format_uart__rx_fifo_size__no_overrun:
    print " "
format_uart__rx_fifo_size__no_overrun__done:
    print "({2}-{3}) tx={4} ({5}-{6})\n"

    format uart_index
    format rx_fifo_size
    format rx_rptr
    format rx_wptr
    format tx_fifo_size
    format tx_rptr
    format tx_wptr

    set @counter ret

format_mcause:
    jump format_mcause__reset strictEqual n null
    jump format_mcause__interrupt greaterThanEq n 0x80000000
    jump format_hex greaterThan n 19
    op mul jump n 2
    op add @counter @counter jump
    format "instr_misalign"; set @counter ret
    format "instr_access_fault"; set @counter ret
    format "illegal_instr"; set @counter ret
    format "breakpoint"; set @counter ret
    format "load_misalign"; set @counter ret
    format "load_access_fault"; set @counter ret
    format "store/AMO_misalign"; set @counter ret
    format "store/AMO_access_fault"; set @counter ret
    format "ecall_from_U-mode"; set @counter ret
    format "ecall_from_S-mode"; set @counter ret
    jump format_hex always; stop
    format "ecall_from_M-mode"; set @counter ret
    format "instr_page_fault"; set @counter ret
    format "load_page_fault"; set @counter ret
    jump format_hex always; stop
    format "store/AMO_page_fault"; set @counter ret
    jump format_hex always; stop
    jump format_hex always; stop
    format "software_check"; set @counter ret
    format "hardware_check"; set @counter ret

format_mcause__reset:
    format "reset"
    set @counter ret

format_mcause__interrupt:
    op and n2 n 0x7fffffff
    op mod rem n2 2
    jump format_hex notEqual rem 1
    jump format_hex greaterThan n2 13
    op sub jump n2 1
    op add @counter @counter jump
    format "S_software_int"; set @counter ret
    format "M_software_int"; set @counter ret
    format "S_timer_int"; set @counter ret
    format "M_timer_int"; set @counter ret
    format "S_external_int"; set @counter ret
    format "M_external_int"; set @counter ret
    format "cntr_overflow_int"; set @counter ret

format_privilege_mode:
    jump format_null strictEqual n null
    jump format_unknown lessThan n 0b00
    jump format_unknown greaterThan n 0b11
    op mul jump n 2
    op add @counter @counter jump
    format "user"; set @counter ret
    format "supervisor"; set @counter ret
    format "reserved"; set @counter ret
    format "machine"; set @counter ret

# creates a marker on the ram proc containing a given address
# the caller should print a format string with a placeholder for the address
# address ->
mark_memory:
    set mark_memory__ret ret

    jump mark_memory__rom lessThan address {{RAM_START}}

    op sub _address address {{RAM_START}}

    # we store 4 bytes in each value
    op idiv _address _address 4

    # get the ram proc containing this address
    op idiv _ram_index _address {{RAM_PROC_VARS}}
    op add _ram_index _ram_index RAM_START_PROC

    op mod x _ram_index MEMORY_WIDTH
    op add x x MEMORY_X

    op idiv y _ram_index MEMORY_WIDTH
    op add y y MEMORY_Y

    jump mark_memory__found always

mark_memory__rom:
    # get rom proc data
    op idiv _rom_index address {{ROM_PROC_BYTES}}

    op mod x _rom_index MEMORY_WIDTH
    op add x x MEMORY_X

    op idiv y _rom_index MEMORY_WIDTH
    op add y y MEMORY_Y

mark_memory__found:
    set n address
    op add ret @counter 1
    jump format_hex always

    setmarker remove mark_memory_id
    makemarker shapeText mark_memory_id x y false

    op sub layer 120 mark_memory_id
    op add layer layer MARKER_START_ID
    setmarker drawLayer mark_memory_id layer

    setmarker radius mark_memory_id 3
    setmarker textHeight mark_memory_id 0.5
    setmarker fontSize mark_memory_id 0.9

    setmarker flushText mark_memory_id false

    op add mark_memory_id mark_memory_id 1
    set @counter mark_memory__ret

#% if false
# {% raw %}
set {{ROM_PROC_BYTES}} null
set {{RAM_PROC_VARS}} null
set {{ROM_START}} null
set {{RAM_START}} null
set {{CPU}} null
set {{CSRS}} null
set {{REGISTERS}} null
set {{DISPLAY}} null
set {{SWITCH}} null
set {{UART0}} null
set {{UART1}} null
set {{UART2}} null
set {{UART3}} null
# {% endraw %}
#% endif
