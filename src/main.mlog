    # constants
    set ERROR_OUTPUT message1
    set RESET_SWITCH switch1
    set PAUSE_SWITCH switch2
    set SINGLE_STEP_SWITCH switch3
    set REGISTERS cell1
    set CSRS processor17
    set DISPLAY display1

    set RAM_X 1  # bottom left ram proc x
    set RAM_Y 1  # bottom left ram proc y
    set RAM_WIDTH 128  # physical width of the ram procs
    set RAM_SIZE 0x8000000  # total ram size in bytes
    set RAM_PROC_SIZE 4096  # variables (not bytes) per ram proc
    set LOOKUP_LINKS 16  # number of ram variable lookup processors
    set LOOKUP_PROC_SIZE 260  # number of variables per lookup proc

    # initialization
reset:
    sensor enabled RESET_SWITCH @enabled
    jump reset equal enabled true

    setrate 500000
    set IPT @ipt  # for debug output

    control enabled PAUSE_SWITCH false

    printflush ERROR_OUTPUT

    set exit_code null

    # find the index of the first linked lookup proc
    # NOTE: the lookup procs must be linked in a contiguous group
    # eg. if you link lookup procs, then a switch, then want to add more lookup procs, you need to replace the proc and re-link everything
    # also, things may fail if the lookups haven't been given enough time to initialize, so do that first
    set i -1
reset__find_lookup_start:
    op add i i 1
    getlink block i
    sensor type block @type
    jump reset__find_lookup_start notEqual type @micro-processor
    read type_var block "_type"
    jump reset__find_lookup_start notEqual type_var "lookup"

    set LOOKUP_START i

    # hack
    read prev_lookup_index block "_index"
    op sub prev_lookup_index prev_lookup_index 1

    # validate the number of linked lookup procs
reset__find_lookup_size:
    read lookup_index block "_index"
    op sub delta lookup_index prev_lookup_index
    jump invalid_lookup_link_order notEqual delta 1
    set prev_lookup_index lookup_index

    op add i i 1
    getlink block i
    sensor type block @type
    jump reset__done_find_lookup_size notEqual type @micro-processor
    read type_var block "_type"
    jump reset__find_lookup_size equal type_var "lookup"

reset__done_find_lookup_size:
    op sub lookup_links i LOOKUP_START
    jump invalid_lookup_link_order notEqual lookup_links LOOKUP_LINKS

    # look up commonly used CSRs
    set csr 0xc00
    op add ret @counter 1
    jump access_csr always
    set CSR_CYCLE variable
    
    set csr 0xc01
    op add ret @counter 1
    jump access_csr always
    set CSR_TIME variable

    set csr 0xc02
    op add ret @counter 1
    jump access_csr always
    set CSR_INSTRET variable

    set csr 0xc80
    op add ret @counter 1
    jump access_csr always
    set CSR_CYCLEH variable
    
    set csr 0xc81
    op add ret @counter 1
    jump access_csr always
    set CSR_TIMEH variable

    set csr 0xc82
    op add ret @counter 1
    jump access_csr always
    set CSR_INSTRETH variable

    # zero all of the registers
    set i 0
reset__zero_registers:
    write 0 REGISTERS i
    op add i i 1
    jump reset__zero_registers lessThan i 32

    # start executing code at address 0
    set pc 0

    # reset instret
    set instret 0
    write 0 CSRS CSR_INSTRET
    write 0 CSRS CSR_INSTRETH

    # start cycle timer
    set next_time_update @time
    set RESET_TIME @time
    set RESET_TICK @tick

main:
    jump main__skip_time_update lessThan @time next_time_update
    op add next_time_update @time 1

    op add ret @counter 1
    jump update_time_and_cycle always

main__skip_time_update:

    # load instruction
    set address pc
    op add ret @counter 1
    jump load_word always
    set instruction result
    
    sensor enabled SINGLE_STEP_SWITCH @enabled
    jump pause_step equal enabled true
unpause_step:

    # decode instruction

    # almost everything needs funct3 and rs1, so just decode them here
    op shr funct3 instruction 12
    op and funct3 funct3 0b111

    # note: rs1_id is stored as a separate variable because FENCE needs it
    op shr rs1_id instruction 15
    op mod rs1_id rs1_id 32 # 2^5 (trunc 5)
    read rs1 REGISTERS rs1_id

    # the lowest 2 bits are always "11" for non-compressed instructions
    op and low_bits instruction 0b11
    jump illegal_instruction notEqual low_bits 0b11

    # counter array based on (opcode >> 2), since the low 2 bits don't matter
    op and opcode instruction 0b1111111
    op shr opcode_jump opcode 2
    op add @counter @counter opcode_jump

    jump decode_load always
    jump illegal_instruction always
    jump illegal_instruction always
    jump FENCE always
    jump decode_arithmetic_imm always
    jump AUIPC always
    jump illegal_instruction always
    jump illegal_instruction always
    jump decode_store always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump decode_arithmetic always
    jump LUI always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump decode_branch always
    jump JALR always
    jump illegal_instruction always
    jump JAL always
    jump decode_system always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always

decode_branch:
    # B-type
    # imm
    op shr imm_12 instruction 19 # instruction[31] -> imm[12]
    op shl imm_11 instruction 4 # instruction[7] -> imm[11]
    op shr imm_10_5 instruction 20 # instruction[30:25] -> imm[10:5]
    op shr imm_4_1 instruction 7 # instruction[11:8] -> imm[4:1]

    op and imm_12 imm_12     0b1000000000000
    op and imm_11 imm_11     0b0100000000000
    op and imm_10_5 imm_10_5 0b0011111100000
    op and imm_4_1 imm_4_1   0b0000000011110

    op add imm imm_12 imm_11
    op add imm imm imm_10_5
    op add imm imm imm_4_1

    # extend sign
    op xor imm imm 0b1000000000000
    op sub imm imm 0b1000000000000
    op and imm imm 0xffffffff

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    op add @counter @counter funct3

    jump BEQ always
    jump BNE always
    jump illegal_instruction always
    jump illegal_instruction always
    jump BLT always
    jump BGE always
    jump BLTU always
    jump BGEU always

decode_load:
    # I-type
    op add ret @counter 1
    jump decode_type_I always

    op add @counter @counter funct3

    jump LB always
    jump LH always
    jump LW always
    jump illegal_instruction always
    jump LBU always
    jump LHU always
    jump illegal_instruction always
    jump illegal_instruction always

decode_store:
    # S-type
    # imm
    op shr imm_11_5 instruction 20 # instruction[31:25] -> imm[11:5]
    op shr imm_4_0 instruction 7 # instruction[11:7] -> imm[4:0]
    
    op and imm_11_5 imm_11_5 0b111111100000
    op and imm_4_0 imm_4_0   0b000000011111

    op add imm imm_11_5 imm_4_0

    # extend sign
    op xor imm imm 0b100000000000
    op sub imm imm 0b100000000000
    op and imm imm 0xffffffff

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    op add @counter @counter funct3

    jump SB always
    jump SH always
    jump SW always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always
    jump illegal_instruction always

decode_system:
    jump illegal_instruction greaterThan funct3 7

    # funct12
    op shr funct12 instruction 20
    op mod funct12 funct12 4096 # 2^12 (trunc 12)

    jump decode_ECALL_EBREAK equal funct3 0

    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # uimm and csr (aliases for readability)
    set uimm rs1_id
    set csr funct12

    # from privileged architecture csr chapter:
    # the top two bits of csr indicate whether the register is read/write (00, 01, 10) or read-only (11)
    op and csr_readonly csr 0b110000000000
    op equal csr_readonly csr_readonly 0b110000000000

    # look up csr variable name
    op add ret @counter 1
    jump access_csr always

    op add @counter @counter funct3

    jump decode_ECALL_EBREAK always # this jump should never actually be taken
    jump CSRRW always
    jump CSRRS always
    jump CSRRC always
    jump illegal_instruction always
    jump CSRRWI always
    jump CSRRSI always
    jump CSRRCI always

decode_ECALL_EBREAK:
    jump ECALL equal funct12 0
    jump EBREAK equal funct12 1
    jump illegal_instruction always

decode_arithmetic_imm:
    # I-type
    op add ret @counter 1
    jump decode_type_I always

    # funct7
    op shr funct7 instruction 25
    op and funct7 funct7 0b1111111

    op add @counter @counter funct3

    jump ADDI always
    jump SLLI always
    jump SLTI always
    jump SLTIU always
    jump XORI always
    jump decode_SRLI_SRAI always
    jump ORI always
    jump ANDI always

decode_SRLI_SRAI:
    jump SRLI equal funct7 0
    jump SRAI equal funct7 32
    jump illegal_instruction always

decode_arithmetic:
    # R-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # rs2
    op shr rs2 instruction 20
    op mod rs2 rs2 32 # 2^5 (trunc 5)
    read rs2 REGISTERS rs2

    # funct7
    op shr funct7 instruction 25
    op and funct7 funct7 0b1111111

    op add @counter @counter funct3

    jump decode_ADD_SUB always
    jump SLL always
    jump SLT always
    jump SLTU always
    jump XOR always
    jump decode_SRL_SRA always
    jump OR always
    jump AND always

decode_ADD_SUB:
    jump ADD equal funct7 0
    jump SUB equal funct7 32
    jump illegal_instruction always

decode_SRL_SRA:
    jump SRL equal funct7 0
    jump SRA equal funct7 32
    jump illegal_instruction always

# common decoder for I-type instructions
decode_type_I:
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 20
    op mod imm imm 4096 # 2^12 (trunc 12)

    # extend sign
    op xor imm imm 0b100000000000
    op sub imm imm 0b100000000000
    op and imm imm 0xffffffff

    set @counter ret

# all instructions jump here after completing successfully
end_instruction:
    # increment instret
    op add instret instret 1
    jump end_instruction__no_overflow lessThan instret 0x100000000

    set instret 0

    read high CSRS CSR_INSTRETH
    op add high high 1
    write high CSRS CSR_INSTRETH

end_instruction__no_overflow:
    write instret CSRS CSR_INSTRET

end_instruction_preserve_instret:
    op add pc pc 4

end_instruction_preserve_pc:
    # halt if the reset switch was manually enabled
    sensor enabled RESET_SWITCH @enabled
    jump main notEqual enabled true
    jump halt always

# exceptions

invalid_lookup_link_order:
    print "Invalid ROM proc lookup link order! Lookups must be linked to the processor in one contiguous chunk in the order specified by the _index variable."
    printflush ERROR_OUTPUT
    jump halt always

illegal_instruction:
    print "Illegal instruction!"
    printflush ERROR_OUTPUT
    jump halt always

illegal_syscall:
    print "Illegal syscall!"
    printflush ERROR_OUTPUT
    jump halt always

instruction_address_misaligned:
    print "Instruction address misaligned!"
    printflush ERROR_OUTPUT
    jump halt always

misaligned_load:
    print "Attempted misaligned load!"
    printflush ERROR_OUTPUT
    jump halt always

misaligned_store:
    print "Attempted misaligned store!"
    printflush ERROR_OUTPUT
    jump halt always

inaccessible_load:
    print "Attempted to load from an inaccessible address!"
    printflush ERROR_OUTPUT
    jump halt always

inaccessible_store:
    print "Attempted to store to an inaccessible address!"
    printflush ERROR_OUTPUT
    jump halt always

# pause/halt

# enable the reset switch, wait until it's disabled, then reset the processor
halt:
    op add ret @counter 1
    jump update_time_and_cycle always

    control enabled RESET_SWITCH true
    jump reset always

# we jump here after instruction fetch if the single-step switch is enabled
pause_step:
    op add ret @counter 1
    jump update_time_and_cycle always

    control enabled PAUSE_SWITCH true
    set pause_step_tick @tick

pause_step__loop:
    sensor enabled RESET_SWITCH @enabled
    jump halt equal reset_enabled true
    sensor enabled PAUSE_SWITCH @enabled
    jump pause_step__loop equal enabled true

    # move RESET_TICK forward by the amount of time we were paused for
    # this should have the effect of pausing cycle while paused here
    op sub delta @tick pause_step_tick
    op add RESET_TICK RESET_TICK delta

    op add ret @counter 1
    jump update_time_and_cycle always

    jump unpause_step always

# helper functions

# update the time/timeh and cycle/cycleh CSRs
# TODO: we could theoretically only update these when they're actually being read, but that would look weird on a debugger
update_time_and_cycle:
    # update time
    op sub time @time RESET_TIME
    op floor time time

    op mod low time 0x100000000
    op shr high time 32

    write low CSRS CSR_TIME
    write high CSRS CSR_TIMEH

    # update cycle
    # we define the number of cycles as "@ipt * ticks since reset"
    # this should be a decent estimation of the number of mlog instructions executed since reset
    op sub cycle @tick RESET_TICK
    op mul cycle cycle @ipt
    op floor cycle cycle

    op mod low cycle 0x100000000
    op shr high cycle 32

    write low CSRS CSR_CYCLE
    write high CSRS CSR_CYCLEH

    set @counter ret

# sign extension function
# value, length -> result
extend_sign:
    # https://graphics.stanford.edu/~seander/bithacks.html#VariableSignExtend
    op sub _mask length 1
    op shl _mask 1 _mask

    op xor result value _mask
    op sub result result _mask
    op and result result 0xffffffff # convert signed to unsigned

    set @counter ret

# converts a pair of two's complement unsigned values to signed, or vice versa
# this converts two values at once because every usage of it needs to convert two values
# value1, value2 -> result1, result2
swap_signedness:
    # value1 < 2^31 ? (value1 + 2^32) % 2^32 : value1 - 2^32
    jump swap_signedness__s2u_1 lessThan value1 0x80000000 # 2^31
    op sub result1 value1 0x100000000 # 2^32
    jump swap_signedness__done_1 always
swap_signedness__s2u_1:
    op add result1 value1 0x100000000
    op mod result1 result1 0x100000000
swap_signedness__done_1:

    jump swap_signedness__s2u_2 lessThan value2 0x80000000
    op sub result2 value2 0x100000000
    jump swap_signedness__done_2 always
swap_signedness__s2u_2:
    op add result2 value2 0x100000000
    op mod result2 result2 0x100000000
swap_signedness__done_2:

    set @counter ret

# helper function to find the ram proc and variable for a given address
# address -> ram, variable
access_ram:
    # we store 4 bytes in each value
    op idiv _address address 4

    # get the ram proc containing this address
    op idiv _ram_index _address RAM_PROC_SIZE

    op mod _ram_x _ram_index RAM_WIDTH
    op add _ram_x _ram_x RAM_X

    op idiv _ram_y _ram_index RAM_WIDTH
    op add _ram_y _ram_y RAM_Y

    getblock building ram _ram_x _ram_y

    # get the variable within the ram proc containing this address
    op mod _address _address RAM_PROC_SIZE
    
    op idiv _lookup _address LOOKUP_PROC_SIZE
    op add _lookup _lookup LOOKUP_START
    getlink _lookup _lookup

    op mod variable _address LOOKUP_PROC_SIZE
    lookup block variable variable
    sensor variable variable @name
    read variable _lookup variable

    set @counter access_ram__ret

# get the variable name in CSRS for the specified CSR
# csr -> variable
access_csr:
    op idiv _lookup csr LOOKUP_PROC_SIZE
    op add _lookup _lookup LOOKUP_START
    getlink _lookup _lookup

    op mod variable csr LOOKUP_PROC_SIZE
    lookup block variable variable
    sensor variable variable @name
    read variable _lookup variable

    set @counter ret

# loads the word from memory that contains the specified address
# address -> result
load_word:
    jump inaccessible_load greaterThanEq address RAM_SIZE

    # locate and read value from ram
    op add access_ram__ret @counter 1
    jump access_ram always
    read value ram variable
    # null is coerced to 0 by swap_endianness

    # tail call, swap_endianness will jump to the ret value of load_word's caller

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# this MUST stay directly after load_word
# value -> result
swap_endianness:
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl _tmp value 8
    op and _tmp _tmp 0xff0000
    op or result result _tmp

    # byte 2 -> byte 1
    op shr _tmp value 8
    op and _tmp _tmp 0xff00
    op or result result _tmp

    # byte 0 -> byte 3
    op shl _tmp value 24
    op and _tmp _tmp 0xff000000
    op or result result _tmp

    set @counter ret

# loads a value with a specified length in bits (8, 16, or 32) from memory
# raises a misaligned-load exception if the address is misaligned for the specified length
# address, length, is_signed -> result
load_value:
    set load_value__ret ret

    # truncate address, because every caller needs to do it anyway
    op mod address address 0x100000000 # 2^32 (trunc 32)

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    jump misaligned_load notEqual _alignment 0

    # load the word containing the address
    op add ret @counter 1
    jump load_word always

    # right shift by (address % 4) bits
    op mod _shift address 4
    op mul _shift _shift 8
    op shr result result _shift

    # truncate to the specified number of bits
    op pow _divisor 2 length
    op mod result result _divisor

    # extend the sign of the value if it's signed
    set value result
    set ret load_value__ret
    jump extend_sign equal is_signed true # tail call

    set @counter load_value__ret

# stores a word to memory at the specified address
# NOTE: does not perform an alignment check
# address, value ->
store_word:
    jump inaccessible_store greaterThanEq address RAM_SIZE

    set store_word__ret ret
    
    op add ret @counter 1
    jump swap_endianness always

    op add access_ram__ret @counter 1
    jump access_ram always
    write result ram variable

    set @counter store_word__ret

# stores a value with a specified length in bits (8, 16, or 32) to memory
# raises a misaligned-store exception if the address is misaligned for the specified length
# address, value, length ->
store_value:
    set store_value__ret ret

    # truncate address, because every caller needs to do it anyway
    op mod address address 0x100000000 # 2^32 (trunc 32)
    jump inaccessible_store greaterThanEq address RAM_SIZE

    # check alignment
    op idiv _bytes length 8
    op mod _alignment address _bytes
    jump misaligned_store notEqual _alignment 0

    # take the low n bits of the value to store, and shift it to line up with the zeros in the mask (big endian)
    op mod _shift address 4
    op mul _shift _shift 8

    op pow _length_squared 2 length
    op mod value value _length_squared
    op shl value value _shift

    # convert the value to little endian
    op add ret @counter 1
    jump swap_endianness always

    # create a bitmask with 0 in the section we want to replace and 1 everywhere else (little endian)
    op sub _shift 24 _shift
    op idiv _shift _shift length
    op mul _shift _shift length

    op sub _bitmask _length_squared 1
    op shl _bitmask _bitmask _shift
    op sub _bitmask 0xffffffff _bitmask

    # load the word containing the address
    op add access_ram__ret @counter 1
    jump access_ram always
    read _word ram variable

    # insert the value into the word
    op and _word _word _bitmask
    op add result result _word

    # store the new value
    write result ram variable

    set @counter store_value__ret

# instruction handlers

LUI:
    # U-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)
    jump end_instruction equal rd 0

    # imm
    op and imm instruction 0b11111111111111111111000000000000

    write imm REGISTERS rd
    jump end_instruction always

AUIPC:
    # U-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)
    jump end_instruction equal rd 0

    # imm
    op and imm instruction 0b11111111111111111111000000000000

    op add result imm pc
    op mod result result 0x100000000 # trunc 32
    write result REGISTERS rd

    jump end_instruction always

JAL:
    # J-type
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm_20 instruction 11 # instruction[31] -> imm[20]
    op shr imm_11 instruction 9 # instruction[20] -> imm[11]
    op shr imm_10_1 instruction 20 # instruction[30:21] -> imm[10:1]

    op and imm_20 imm_20         0b100000000000000000000
    op and imm_19_12 instruction 0b011111111000000000000 # instruction[19:12] -> imm[19:12]
    op and imm_11 imm_11         0b000000000100000000000
    op and imm_10_1 imm_10_1     0b000000000011111111110

    op add imm imm_20 imm_19_12
    op add imm imm imm_11
    op add imm imm imm_10_1

    # extend sign
    op xor imm imm 0b100000000000000000000
    op sub imm imm 0b100000000000000000000
    op and imm imm 0xffffffff

    # instruction handler

    op add target pc imm

jump_to_target:
    op mod target target 0x100000000 # trunc 32

    op mod remainder target 4
    jump instruction_address_misaligned notEqual remainder 0

    jump jump_to_target__no_write equal rd 0

    op add result pc 4
    op mod result result 0x100000000 # trunc 32
    write result REGISTERS rd

jump_to_target__no_write:
    set pc target
    jump end_instruction_preserve_pc always

JALR:
    op add ret @counter 1
    jump decode_type_I always

    op add target rs1 imm
    jump jump_to_target always

BEQ:
    op add target pc imm
    set rd 0
    jump jump_to_target equal rs1 rs2
    jump end_instruction always

BNE:
    op add target pc imm
    set rd 0
    jump jump_to_target notEqual rs1 rs2
    jump end_instruction always

BLT:
    set value1 rs1
    set value2 rs2
    op add ret @counter 1
    jump swap_signedness always

    op add target pc imm
    set rd 0
    jump jump_to_target lessThan result1 result2
    jump end_instruction always

BGE:
    set value1 rs1
    set value2 rs2
    op add ret @counter 1
    jump swap_signedness always

    op add target pc imm
    set rd 0
    jump jump_to_target greaterThanEq result1 result2
    jump end_instruction always

BLTU:
    op add target pc imm
    set rd 0
    jump jump_to_target lessThan rs1 rs2
    jump end_instruction always

BGEU:
    op add target pc imm
    set rd 0
    jump jump_to_target greaterThanEq rs1 rs2
    jump end_instruction always

LB:
    op add address rs1 imm
    set length 8
    set is_signed true
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LH:
    op add address rs1 imm
    set length 16
    set is_signed true
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LW:
    op add address rs1 imm
    set length 32
    set is_signed false
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LBU:
    op add address rs1 imm
    set length 8
    set is_signed false
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

LHU:
    op add address rs1 imm
    set length 16
    set is_signed false
    op add ret @counter 1
    jump load_value always

    jump end_instruction equal rd 0
    write result REGISTERS rd
    jump end_instruction always

SB:
    op add address rs1 imm
    set value rs2
    set length 8
    op add ret @counter 1
    jump store_value always
    jump end_instruction always

SH:
    op add address rs1 imm
    set value rs2
    set length 16
    op add ret @counter 1
    jump store_value always
    jump end_instruction always

SW:
    op add address rs1 imm
    set value rs2
    set length 32
    op add ret @counter 1
    jump store_value always
    jump end_instruction always

ADDI:
    jump end_instruction equal rd 0

    op add result rs1 imm
    op mod result result 0x100000000 # 2^32 (trunc 32)
    write result REGISTERS rd

    jump end_instruction always

SLTI:
    jump end_instruction equal rd 0

    set value1 rs1
    set value2 imm
    op add ret @counter 1
    jump swap_signedness always

    op lessThan result result1 result2
    write result REGISTERS rd

    jump end_instruction always

SLTIU:
    jump end_instruction equal rd 0

    op lessThan result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

XORI:
    jump end_instruction equal rd 0

    op xor result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

ORI:
    jump end_instruction equal rd 0

    op or result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

ANDI:
    jump end_instruction equal rd 0

    op and result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

SLLI:
    # put the check here because there are no other instructions with this opcode and funct3
    jump illegal_instruction notEqual funct7 0

    jump end_instruction equal rd 0

    op mod imm imm 32 # 2^5 (trunc 5)

    # truncate before shifting to avoid overflowing 52 integer bits in double
    op sub length 32 imm
    op pow divisor 2 length
    op mod rs1 rs1 divisor

    op shl result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

SRLI:
    jump end_instruction equal rd 0

    op mod imm imm 32 # 2^5 (trunc 5)

    op shr result rs1 imm
    write result REGISTERS rd

    jump end_instruction always

SRAI:
    jump end_instruction equal rd 0

    op mod imm imm 32 # 2^5 (trunc 5)

    op shr value rs1 imm

    op sub length 32 imm
    op add ret @counter 1
    jump extend_sign always

    write result REGISTERS rd

    jump end_instruction always

# most of the register-register instructions are identical to their register-immediate counterparts
# so just set imm to rs2 and reuse the existing logic

ADD:
    set imm rs2
    jump ADDI always

SUB:
    # apply two's complement to negate the value in rs2 and put it into imm
    op sub imm 0x100000000 rs2
    op mod imm imm 0x100000000

    jump ADDI always

SLL:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump SLLI always

SLT:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump SLTI always

SLTU:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump SLTIU always

XOR:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump XORI always

SRL:
    set imm rs2
    jump SRLI always

SRA:
    set imm rs2
    jump SRAI always

OR:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump ORI always

AND:
    jump illegal_instruction notEqual funct7 0

    set imm rs2
    jump ANDI always

FENCE:
    jump illegal_instruction notEqual funct3 0

    # I-type, but without sign extension
    # rd
    op shr rd instruction 7
    op mod rd rd 32 # 2^5 (trunc 5)

    # imm
    op shr imm instruction 20
    op mod imm imm 4096 # 2^12 (trunc 12)

    # PAUSE
    # TODO: there's probably a better way to do this
    jump FENCE__not_pause notEqual rd 0
    jump FENCE__not_pause notEqual rs1_id 0
    jump FENCE__not_pause notEqual imm 0b000000010000

    wait 0.00001

FENCE__not_pause:
    # no-op
    jump end_instruction always

ECALL:
    read a0 REGISTERS 10
    read a1 REGISTERS 11
    read a2 REGISTERS 12
    read a3 REGISTERS 13
    read a4 REGISTERS 14
    read a5 REGISTERS 15
    read a7 REGISTERS 17

    jump illegal_syscall lessThan a7 0 # this SHOULD never happen, but just in case
    jump illegal_syscall greaterThanEq a7 20 # number of syscalls

    op add @counter @counter a7
    
    jump ECALL_halt always
    jump ECALL_printchar always
    jump ECALL_printflush always
    jump ECALL_draw_clear always
    jump ECALL_draw_color always
    jump ECALL_draw_col always
    jump ECALL_draw_stroke always
    jump ECALL_draw_line always
    jump ECALL_draw_rect always
    jump ECALL_draw_lineRect always
    jump ECALL_draw_poly always
    jump ECALL_draw_linePoly always
    jump ECALL_draw_triangle always
    jump ECALL_draw_image always
    jump ECALL_draw_print always
    jump ECALL_draw_translate always
    jump ECALL_draw_scale always
    jump ECALL_draw_rotate always
    jump ECALL_draw_reset always
    jump ECALL_drawflush always

ECALL_halt:
    set exit_code a0
    jump halt always

ECALL_printchar:
    printchar a0
    jump end_instruction_preserve_instret always

ECALL_printflush:
    printflush ERROR_OUTPUT
    jump end_instruction_preserve_instret always

ECALL_draw_clear:
    draw clear a0 a1 a2
    jump end_instruction_preserve_instret always

ECALL_draw_color:
    draw color a0 a1 a2 a3
    jump end_instruction_preserve_instret always

ECALL_draw_col:
    op mul a0 a0 %00000001
    draw col a0
    jump end_instruction_preserve_instret always

ECALL_draw_stroke:
    draw stroke a0
    jump end_instruction_preserve_instret always

ECALL_draw_line:
    draw line a0 a1 a2 a3
    jump end_instruction_preserve_instret always

ECALL_draw_rect:
    draw rect a0 a1 a2 a3
    jump end_instruction_preserve_instret always

ECALL_draw_lineRect:
    draw lineRect a0 a1 a2 a3
    jump end_instruction_preserve_instret always

ECALL_draw_poly:
    draw poly a0 a1 a2 a3 a4
    jump end_instruction_preserve_instret always

ECALL_draw_linePoly:
    draw linePoly a0 a1 a2 a3 a4
    jump end_instruction_preserve_instret always

ECALL_draw_triangle:
    draw triangle a0 a1 a2 a3 a4 a5
    jump end_instruction_preserve_instret always

ECALL_draw_image:
    op mod a2 a2 4 # number of indices
    op mul a2 a2 2 # instructions per index
    op add @counter @counter a2

    lookup block image a3; jump ECALL_draw_image__end always
    lookup unit image a3; jump ECALL_draw_image__end always
    lookup item image a3; jump ECALL_draw_image__end always
    lookup liquid image a3; jump ECALL_draw_image__end always

ECALL_draw_image__end:
    jump ECALL_draw_image__lookup_fail equal image null

    write 1 REGISTERS 10
    draw image a0 a1 image a4 a5
    jump end_instruction_preserve_instret always

ECALL_draw_image__lookup_fail:
    write 0 REGISTERS 10
    jump end_instruction_preserve_instret always

ECALL_draw_print:
    op mod a2 a2 9 # number of indices
    op mul a2 a2 2 # instructions per index
    op add @counter @counter a2

    draw print a0 a1 bottom; jump end_instruction_preserve_instret always
    draw print a0 a1 bottomLeft; jump end_instruction_preserve_instret always
    draw print a0 a1 bottomRight; jump end_instruction_preserve_instret always
    draw print a0 a1 center; jump end_instruction_preserve_instret always
    draw print a0 a1 left; jump end_instruction_preserve_instret always
    draw print a0 a1 right; jump end_instruction_preserve_instret always
    draw print a0 a1 top; jump end_instruction_preserve_instret always
    draw print a0 a1 topLeft; jump end_instruction_preserve_instret always
    draw print a0 a1 topRight; jump end_instruction_preserve_instret always

ECALL_draw_translate:
    draw translate a0 a1
    jump end_instruction_preserve_instret always

ECALL_draw_scale:
    draw scale a0 a1
    jump end_instruction_preserve_instret always

ECALL_draw_rotate:
    draw rotate a0
    jump end_instruction_preserve_instret always

ECALL_draw_reset:
    draw reset
    jump end_instruction_preserve_instret always

ECALL_drawflush:
    drawflush DISPLAY
    jump end_instruction_preserve_instret always

EBREAK:
    op add ret @counter 1
    jump update_time_and_cycle always

    control enabled PAUSE_SWITCH true
    print "Paused on EBREAK, disable pause switch to continue"
    printflush ERROR_OUTPUT

    set pause_tick @tick

EBREAK__loop:
    sensor reset_enabled RESET_SWITCH @enabled
    jump halt equal reset_enabled true
    sensor pause_enabled PAUSE_SWITCH @enabled
    jump EBREAK__loop equal pause_enabled true

    # move RESET_TICK forward by the amount of time we were paused for
    # this should have the effect of pausing cycle while paused here
    op sub delta @tick pause_tick
    op add RESET_TICK RESET_TICK delta

    op add ret @counter 1
    jump update_time_and_cycle always

    printflush ERROR_OUTPUT
    jump end_instruction_preserve_instret always

CSRRW:
    # technically we're not supposed to perform this read, but it doesn't really make a difference
    read value CSRS variable

    jump illegal_instruction equal csr_readonly true
    write rs1 CSRS variable

    jump end_instruction equal rd 0
    write value REGISTERS rd

    jump end_instruction always

CSRRS:
    read value CSRS variable

    jump CSRRS__skip_write equal rs1_id 0
    jump illegal_instruction equal csr_readonly true

    op or result rs1 value

    write result CSRS variable

CSRRS__skip_write:
    jump end_instruction equal rd 0
    write value REGISTERS rd

    jump end_instruction always

CSRRC:
    read value CSRS variable

    jump CSRRC__skip_write equal rs1_id 0
    jump illegal_instruction equal csr_readonly true

    op not result rs1
    op and result result value

    write result CSRS variable

CSRRC__skip_write:
    jump end_instruction equal rd 0
    write value REGISTERS rd

    jump end_instruction always

CSRRWI:
    set rs1 uimm
    jump CSRRW always

CSRRSI:
    # rs1_id is already equal to uimm, that's where we got uimm from
    set rs1 uimm
    jump CSRRS always

CSRRCI:
    set rs1 uimm
    jump CSRRC always
