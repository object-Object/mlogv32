reset:
    setrate 60
    wait 0.00001
    set STATE "ready"
    stop
    set STATE "running"
    setrate 500000

    set CPU processor17
    set INCR processor18
    
    read MEMORY_X CPU "MEMORY_X"
    read MEMORY_Y CPU "MEMORY_Y"
    read MEMORY_WIDTH CPU "MEMORY_WIDTH"
    read MEMORY_PROC_SIZE CPU "MEMORY_PROC_SIZE"
    read LOOKUP_PROC_SIZE CPU "LOOKUP_PROC_SIZE"
    read ROM_SIZE CPU "ROM_SIZE"
    read MEMORY_END_INDEX CPU "MEMORY_END_INDEX"

    # find the index of the first linked lookup proc
    # NOTE: the lookup procs must be linked in a contiguous group
    # eg. if you link lookup procs, then a switch, then want to add more lookup procs, you need to replace the proc and re-link everything
    # also, things may fail if the lookups haven't been given enough time to initialize, so do that first
    set i -1
reset__find_lookup_start:
    op add i i 1
    getlink block i
    sensor type block @type
    jump reset__find_lookup_start notEqual type @micro-processor
    read type_var block "_type"
    jump reset__find_lookup_start notEqual type_var "lookup"

    set LOOKUP_START i

    # read __etext from address 0
    set address 0
    op add ret @counter 1
    jump load_word always
    set __etext result

    # if __etext is 0, decode the entire ROM
    jump reset__nonzero_etext notEqual __etext 0
    set __etext ROM_SIZE
reset__nonzero_etext:

    # start decoding at address 4
    # (address 0 is __etext)
    set decode_address 4
    set instruction_var null
    set icache_var null

    set DECODE_DURATION null
    set START_TIME @time

main:
    # get the current instruction processor and variable
    jump main__instruction_var_valid notEqual instruction_var null
    set address decode_address
    op add access_ram__ret @counter 1
    jump access_ram always
    set instruction_ram ram
    set instruction_var variable
main__instruction_var_valid:

    # read instruction
    read value instruction_ram instruction_var
    op add ret @counter 1
    jump swap_endianness always
    set instruction result

    # decode instruction

    # some instructions don't use all of the args, so set the rest to null
    set arg1 null
    set arg2 null
    set arg3 null

    # almost everything needs funct3, so just decode it here
    op shr funct3 instruction 12
    op and funct3 funct3 0b111

    # many decoders use funct3 * 2 as a counter array jump, so calculate that here to save space
    op mul funct3_x2 funct3 2

    # the lowest 2 bits are always "11" for non-compressed instructions
    op and low_bits instruction 0b11
    jump decode_illegal_instruction notEqual low_bits 0b11

    # counter array based on (opcode >> 2), since the low 2 bits don't matter
    op and opcode instruction 0b1111111
    op shr jump opcode 2
    op add @counter @counter jump

    jump decode_LOAD always
    jump decode_illegal_instruction always # LOAD-FP
    jump decode_illegal_instruction always # custom-0
    jump decode_MISC-MEM always
    jump decode_OP-IMM always
    jump decode_AUIPC always
    jump decode_illegal_instruction always # OP-IMM-32
    jump decode_illegal_instruction always # 48b
    jump decode_STORE always
    jump decode_illegal_instruction always # STORE-FP
    jump decode_illegal_instruction always # custom-1
    jump decode_illegal_instruction always # AMO
    jump decode_OP always
    jump decode_LUI always
    jump decode_illegal_instruction always # OP-32
    jump decode_illegal_instruction always # 64b
    jump decode_illegal_instruction always # MADD
    jump decode_illegal_instruction always # MSUB
    jump decode_illegal_instruction always # NMSUB
    jump decode_illegal_instruction always # NMADD
    jump decode_illegal_instruction always # OP-FP
    jump decode_illegal_instruction always # OP-V
    jump decode_illegal_instruction always # custom-2/rv128
    jump decode_illegal_instruction always # 48b
    jump decode_BRANCH always
    jump decode_JALR always
    jump decode_illegal_instruction always # reserved
    jump decode_JAL always
    jump decode_SYSTEM always
    jump decode_illegal_instruction always # OP-VE
    jump decode_illegal_instruction always # custom-3/rv128
    jump decode_illegal_instruction always # >=80b

decode_LUI:
    set op_id 1 # LUI
    jump decode_U-type always

decode_AUIPC:
    set op_id 2 # AUIPC
    
decode_U-type:
    # U-type: arg1=rd, arg2=imm
    # rd
    op shr arg1 instruction 7
    op mod arg1 arg1 32 # 2^5 (trunc 5)

    # imm
    op and arg2 instruction 0b11111111111111111111000000000000

    jump end_decode always

decode_JAL:
    # J-type: arg1=rd, arg2=imm
    # rd
    op shr arg1 instruction 7
    op mod arg1 arg1 32 # 2^5 (trunc 5)

    # imm
    op shr imm_20 instruction 11 # instruction[31] -> imm[20]
    op shr imm_11 instruction 9 # instruction[20] -> imm[11]
    op shr imm_10_1 instruction 20 # instruction[30:21] -> imm[10:1]

    op and imm_20 imm_20         0b100000000000000000000
    op and imm_19_12 instruction 0b011111111000000000000 # instruction[19:12] -> imm[19:12]
    op and imm_11 imm_11         0b000000000100000000000
    op and imm_10_1 imm_10_1     0b000000000011111111110

    op add arg2 imm_20 imm_19_12
    op add arg2 arg2 imm_11
    op add arg2 arg2 imm_10_1

    # extend sign
    op xor arg2 arg2 0b100000000000000000000
    op sub arg2 arg2 0b100000000000000000000
    op and arg2 arg2 0xffffffff

    set op_id 3 # JAL
    jump end_decode always

decode_JALR:
    set op_id 4 # JALR
    jump decode_I-type always

decode_BRANCH:
    # B-type: arg1=rs1, arg2=rs2, arg3=imm
    # rs1
    op shr arg1 instruction 15
    op mod arg1 arg1 32 # 2^5 (trunc 5)

    # rs2
    op shr arg2 instruction 20
    op mod arg2 arg2 32 # 2^5 (trunc 5)

    # imm
    op shr imm_12 instruction 19 # instruction[31] -> imm[12]
    op shl imm_11 instruction 4 # instruction[7] -> imm[11]
    op shr imm_10_5 instruction 20 # instruction[30:25] -> imm[10:5]
    op shr imm_4_1 instruction 7 # instruction[11:8] -> imm[4:1]

    op and imm_12 imm_12     0b1000000000000
    op and imm_11 imm_11     0b0100000000000
    op and imm_10_5 imm_10_5 0b0011111100000
    op and imm_4_1 imm_4_1   0b0000000011110

    op add arg3 imm_12 imm_11
    op add arg3 arg3 imm_10_5
    op add arg3 arg3 imm_4_1

    # extend sign
    op xor arg3 arg3 0b1000000000000
    op sub arg3 arg3 0b1000000000000
    op and arg3 arg3 0xffffffff

    op add @counter @counter funct3_x2

    set op_id 5; jump end_decode always # BEQ
    set op_id 6; jump end_decode always # BNE
    jump decode_illegal_instruction always; stop # this stop should never be executed, it's just to fill space
    jump decode_illegal_instruction always; stop
    set op_id 7; jump end_decode always # BLT
    set op_id 8; jump end_decode always # BGE
    set op_id 9; jump end_decode always # BLTU
    set op_id 10; jump end_decode always # BGEU

decode_LOAD:
    jump decode_illegal_instruction greaterThanEq funct3 6

    op add @counter @counter funct3_x2

    set op_id 11; jump decode_I-type always # LB
    set op_id 12; jump decode_I-type always # LH
    set op_id 13; jump decode_I-type always # LW
    jump decode_illegal_instruction always; stop
    set op_id 14; jump decode_I-type always # LBU
    set op_id 15; jump decode_I-type always # LHU

decode_STORE:
    # S-type: arg1=rs1, arg2=rs2, arg3=imm
    # rs1
    op shr arg1 instruction 15
    op mod arg1 arg1 32 # 2^5 (trunc 5)

    # rs2
    op shr arg2 instruction 20
    op mod arg2 arg2 32 # 2^5 (trunc 5)

    # imm
    op shr imm_11_5 instruction 20 # instruction[31:25] -> imm[11:5]
    op shr imm_4_0 instruction 7 # instruction[11:7] -> imm[4:0]
    
    op and imm_11_5 imm_11_5 0b111111100000
    op and imm_4_0 imm_4_0   0b000000011111

    op add arg3 imm_11_5 imm_4_0

    # extend sign
    op xor arg3 arg3 0b100000000000
    op sub arg3 arg3 0b100000000000
    op and arg3 arg3 0xffffffff

    jump decode_illegal_instruction greaterThanEq funct3 3

    op add @counter @counter funct3_x2

    set op_id 16; jump end_decode always # SB
    set op_id 17; jump end_decode always # SH
    set op_id 18; jump end_decode always # SW

decode_OP-IMM:
    # funct7
    op shr funct7 instruction 25
    op and funct7 funct7 0b1111111

    op add @counter @counter funct3_x2

    set op_id 19; jump decode_I-type always # ADDI
    jump decode_SLLI equal funct7 0; jump decode_illegal_instruction always
    set op_id 20; jump decode_I-type always # SLTI
    set op_id 21; jump decode_I-type always # SLTIU
    set op_id 22; jump decode_I-type always # XORI
    jump decode_SRLI_SRAI always; stop
    set op_id 23; jump decode_I-type always # ORI
    set op_id 24; jump decode_I-type always # ANDI

decode_SLLI:
    # shamt is encoded in the low 5 bits of imm, so sign extension is redundant
    set op_id 25 # SLLI
    jump decode_I-type_no_extend_sign always

decode_SRLI_SRAI:
    set op_id 26 # SRLI
    jump decode_I-type_no_extend_sign equal funct7 0b0000000

    # HACK: zero out funct7 in the instruction so it's not included in imm
    op and instruction instruction 0b00000001111111111111111111111111
    set op_id 27 # SRAI
    jump decode_I-type_no_extend_sign equal funct7 0b0100000

    jump decode_illegal_instruction always

decode_OP:
    # R-type: arg1=rd, arg2=rs1, arg3=rs2
    # rd
    op shr arg1 instruction 7
    op mod arg1 arg1 32 # 2^5 (trunc 5)

    # rs1
    op shr arg2 instruction 15
    op mod arg2 arg2 32 # 2^5 (trunc 5)

    # rs2
    op shr arg3 instruction 20
    op mod arg3 arg3 32 # 2^5 (trunc 5)

    # funct7
    op shr funct7 instruction 25
    op and funct7 funct7 0b1111111

    jump decode_OP_0000000 equal funct7 0b0000000
    jump decode_OP_0100000 equal funct7 0b0100000
    jump decode_illegal_instruction always

decode_OP_0000000:
    op add @counter @counter funct3_x2

    set op_id 28; jump end_decode always # ADD
    set op_id 30; jump end_decode always # SLL
    set op_id 31; jump end_decode always # SLT
    set op_id 32; jump end_decode always # SLTU
    set op_id 33; jump end_decode always # XOR
    set op_id 34; jump end_decode always # SRL
    set op_id 36; jump end_decode always # OR
    set op_id 37; jump end_decode always # AND

decode_OP_0100000:
    set op_id 29 # SUB
    jump end_decode equal funct3 0b000

    set op_id 35 # SRA
    jump end_decode equal funct3 0b101

    jump decode_illegal_instruction always

decode_MISC-MEM:
    jump decode_illegal_instruction notEqual funct3 0

    set op_id 38 # FENCE
    jump decode_I-type_no_extend_sign always

decode_SYSTEM:
    op add @counter @counter funct3_x2

    set op_id 39; jump decode_I-type_no_extend_sign always # PRIV
    set op_id 40; jump decode_I-type_no_extend_sign always # CSRRW
    set op_id 41; jump decode_I-type_no_extend_sign always # CSRRS
    set op_id 42; jump decode_I-type_no_extend_sign always # CSRRC
    jump decode_illegal_instruction always; stop
    set op_id 43; jump decode_I-type_no_extend_sign always # CSRRWI
    set op_id 44; jump decode_I-type_no_extend_sign always # CSRRSI
    set op_id 45; jump decode_I-type_no_extend_sign always # CSRRCI

# common decoder for I-type instructions
# this should be called AFTER setting op_id
# arg1=rd, arg2=rs1, arg3=imm
decode_I-type:
    set decode_I-type__extend_sign true
decode_I-type_no_extend_sign:
    # rd
    op shr arg1 instruction 7
    op mod arg1 arg1 32 # 2^5 (trunc 5)

    # rs1
    op shr arg2 instruction 15
    op mod arg2 arg2 32 # 2^5 (trunc 5)

    # imm
    op shr arg3 instruction 20
    op mod arg3 arg3 4096 # 2^12 (trunc 12)

    # if we jumped to no_extend_sign, this value will always be null, so skip sign extension
    # otherwise, set it back to null and perform sign extension
    jump end_decode notEqual decode_I-type__extend_sign true
    set decode_I-type__extend_sign null

    # extend sign of imm
    op xor arg3 arg3 0b100000000000
    op sub arg3 arg3 0b100000000000
    op and arg3 arg3 0xffffffff

    jump end_decode always

# must stay directly before end_decode
decode_illegal_instruction:
    # use 0 as the illegal instruction id because null coerces to 0
    set op_id 0

    # set arguments to null to avoid confusion / storing unnecessary data
    set arg1 null
    set arg2 null
    set arg3 null

# all decoders jump here after completing successfully
end_decode:
    # get the current instruction cache processor and variable
    jump end_decode__icache_var_valid notEqual icache_var null
    op add _address MEMORY_END_INDEX decode_address
    op add access_ram__ret @counter 1
    jump access_ram_raw always
    set icache_ram ram
    set icache_var variable
end_decode__icache_var_valid:

    write op_id icache_ram icache_var
    read icache_var INCR icache_var
    write arg1 icache_ram icache_var
    read icache_var INCR icache_var
    write arg2 icache_ram icache_var
    read icache_var INCR icache_var
    write arg3 icache_ram icache_var
    read icache_var INCR icache_var

    op add decode_address decode_address 4
    read instruction_var INCR instruction_var

    jump main lessThan decode_address __etext

    # done!
    op sub DECODE_DURATION @time START_TIME
    read counter CPU "@counter"
    op add counter counter 1
    write counter CPU "@counter"
    jump reset always

# helper functions

# helper function to find the ram proc and variable for a given address
# address -> ram, variable
access_ram:
    # we store 4 bytes in each value
    op idiv _address address 4

access_ram_raw:
    # get the ram proc containing this address
    op idiv _ram_index _address MEMORY_PROC_SIZE

    op mod _ram_x _ram_index MEMORY_WIDTH
    op add _ram_x _ram_x MEMORY_X

    op idiv _ram_y _ram_index MEMORY_WIDTH
    op add _ram_y _ram_y MEMORY_Y

    getblock building ram _ram_x _ram_y

    # get the variable within the ram proc containing this address
    op mod _address _address MEMORY_PROC_SIZE
    
    op idiv _lookup _address LOOKUP_PROC_SIZE
    op add _lookup _lookup LOOKUP_START
    getlink _lookup _lookup

    op mod variable _address LOOKUP_PROC_SIZE
    lookup block variable variable
    sensor variable variable @name
    read variable _lookup variable

    set @counter access_ram__ret

# loads the word from memory that contains the specified address
# address -> result
load_word:
    # locate and read value from ram
    op add access_ram__ret @counter 1
    jump access_ram always
    read value ram variable
    # null is coerced to 0 by swap_endianness

    # tail call, swap_endianness will jump to the ret value of load_word's caller

# converts a little endian 32-bit number to big endian, or vice versa
# https://stackoverflow.com/a/2182184
# this MUST stay directly after load_word
# value -> result
swap_endianness:
    # byte 3 -> byte 0
    op shr result value 24
    op and result result 0xff

    # byte 1 -> byte 2
    op shl _tmp value 8
    op and _tmp _tmp 0xff0000
    op or result result _tmp

    # byte 2 -> byte 1
    op shr _tmp value 8
    op and _tmp _tmp 0xff00
    op or result result _tmp

    # byte 0 -> byte 3
    op shl _tmp value 24
    op and _tmp _tmp 0xff000000
    op or result result _tmp

    set @counter ret
